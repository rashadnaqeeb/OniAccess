---
phase: 02-input-architecture
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - OniAccess/Input/WorldHandler.cs
  - OniAccess/Input/HelpHandler.cs
  - OniAccess/Toggle/VanillaMode.cs
  - OniAccess/Mod.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "WorldHandler is the default handler that activates when the mod is on and no menu is open, claiming only F12 for help"
    - "F12 activates HelpHandler which presents a navigable list of the previous handler's HelpEntries, stepped through with Up/Down arrows, exited with Escape or F12"
    - "VanillaMode toggle OFF speaks confirmation then deactivates ALL handlers and disables speech; toggle ON speaks confirmation then detects current state and activates appropriate handler"
    - "Old Phase 1 input files (HotkeyRegistry, InputInterceptor, AccessContext, HotkeyModifier) are deleted and Mod.cs uses the new system"
  artifacts:
    - path: "OniAccess/Input/WorldHandler.cs"
      provides: "Default IAccessHandler for world view -- selective claim, F12 help"
    - path: "OniAccess/Input/HelpHandler.cs"
      provides: "IAccessHandler that presents navigable help list with Up/Down/Escape navigation"
    - path: "OniAccess/Toggle/VanillaMode.cs"
      provides: "Redesigned toggle with HandlerStack.DeactivateAll on OFF, ContextDetector.DetectAndActivate on ON"
    - path: "OniAccess/Mod.cs"
      provides: "Updated entry point creating KeyPoller instead of InputInterceptor, no HotkeyRegistry calls"
  key_links:
    - from: "OniAccess/Input/WorldHandler.cs"
      to: "OniAccess/Input/HelpHandler.cs"
      via: "WorldHandler.HandleUnboundKey(F12) pushes HelpHandler onto HandlerStack"
      pattern: "HandlerStack\\.Push.*HelpHandler"
    - from: "OniAccess/Input/HelpHandler.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "HelpHandler pops itself on Escape/F12 to return to previous handler"
      pattern: "HandlerStack\\.Pop"
    - from: "OniAccess/Toggle/VanillaMode.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "Toggle OFF calls HandlerStack.DeactivateAll()"
      pattern: "HandlerStack\\.DeactivateAll"
    - from: "OniAccess/Toggle/VanillaMode.cs"
      to: "OniAccess/Input/ContextDetector.cs"
      via: "Toggle ON calls ContextDetector.DetectAndActivate()"
      pattern: "ContextDetector\\.DetectAndActivate"
    - from: "OniAccess/Mod.cs"
      to: "OniAccess/Input/KeyPoller.cs"
      via: "OnLoad creates KeyPoller GameObject instead of InputInterceptor"
      pattern: "AddComponent<KeyPoller>"
---

<objective>
Implement the concrete handlers (WorldHandler, HelpHandler), redesign VanillaMode for full handler-stack integration, migrate Mod.cs to the new input system, and delete all Phase 1 input files that are now replaced.

Purpose: This plan makes the architecture from 02-01 functional end-to-end. WorldHandler is the default "nothing special is happening" handler. HelpHandler gives F12 its navigable list behavior. VanillaMode properly deactivates/reactivates the entire handler stack. Old code is removed so there's no confusion about which system is active.

Output: 2 new handler files, 3 modified files, 4 deleted files. The mod's input system is fully migrated from Phase 1's flat registry to Phase 2's handler architecture.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-input-architecture/02-RESEARCH.md
@.planning/phases/02-input-architecture/02-01-SUMMARY.md

Locked decisions:
- F12 opens a navigable list (arrow keys step through entries), not a speech dump
- Show only the active handler's keys -- no global keys mixed in
- When mod is on, there is always an active handler (context detection ensures this), so F12 always has content
- Toggle OFF: speak "Oni-Access off" then full disable (all handlers deactivate, keys pass through, speech stops, only Ctrl+Shift+F12 remains)
- Toggle ON: speak "Oni-Access on" only (no state dump), immediately detect current state and activate handler
- No background work when mod is off -- full stop
- Mode announcements interrupt current speech (handler.OnActivate speaks DisplayName)
- Returning to world view is also announced

Deferred (do NOT implement):
- WASD camera panning -- Phase 4
- Actual mode announcement speech for specific screens -- Phase 3+
- Menu-specific full-capture key lists -- Phase 3
- Speech sequencing for container/focused-item -- Phase 3

Phase 1 files to DELETE (replaced by 02-01 infrastructure):
- OniAccess/Input/HotkeyRegistry.cs (replaced by IAccessHandler per-handler key declarations)
- OniAccess/Input/InputInterceptor.cs (replaced by KeyPoller + ModInputRouter)
- OniAccess/Input/AccessContext.cs (replaced by handler stack -- active handler IS the context)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WorldHandler, HelpHandler, and update strings</name>
  <files>
    OniAccess/Input/WorldHandler.cs
    OniAccess/Input/HelpHandler.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
Create two handler implementations and update LocStrings:

**OniAccess/Input/WorldHandler.cs:**
The default handler active when no menu/overlay is open. Per locked decision: when mod is on, there is always an active handler. WorldHandler is that baseline.

```csharp
namespace OniAccess.Input
{
    /// Default handler for world view. Selective claim (CapturesAllInput = false).
    /// Phase 2: only handles F12 for help. Phase 4 adds arrow keys for cursor movement.
    public class WorldHandler : IAccessHandler
    {
        public string DisplayName => STRINGS.ONIACCESS.HANDLERS.WORLD_VIEW;
        public bool CapturesAllInput => false;

        public System.Collections.Generic.IReadOnlyList<HelpEntry> HelpEntries { get; }
            = new System.Collections.Generic.List<HelpEntry>
            {
                new HelpEntry("F12", STRINGS.ONIACCESS.HOTKEYS.CONTEXT_HELP),
                new HelpEntry("Ctrl+Shift+F12", STRINGS.ONIACCESS.HOTKEYS.TOGGLE_MOD),
            }.AsReadOnly();

        public bool HandleKeyDown(KButtonEvent e) => false;
        public bool HandleKeyUp(KButtonEvent e) => false;

        public bool HandleUnboundKey(UnityEngine.KeyCode keyCode)
        {
            if (keyCode == UnityEngine.KeyCode.F12)
            {
                // Push HelpHandler with THIS handler's help entries
                HandlerStack.Push(new HelpHandler(HelpEntries));
                return true;
            }
            return false;
        }

        public void OnActivate()
        {
            Speech.SpeechPipeline.SpeakInterrupt(DisplayName);
        }

        public void OnDeactivate() { }
    }
}
```

**OniAccess/Input/HelpHandler.cs:**
A full-capture handler that presents a navigable list. Per locked decision: F12 opens a navigable list, Up/Down step through entries, Escape or F12 again closes it.

```csharp
namespace OniAccess.Input
{
    /// Handler for F12 help mode. Captures all input.
    /// Speaks help entries one at a time with Up/Down arrow navigation.
    /// Escape or F12 returns to the previous handler.
    public class HelpHandler : IAccessHandler
    {
        private readonly System.Collections.Generic.IReadOnlyList<HelpEntry> _entries;
        private int _currentIndex;

        public string DisplayName => STRINGS.ONIACCESS.HANDLERS.HELP;
        public bool CapturesAllInput => true;

        /// HelpHandler's own help entries describe how to navigate the help list itself
        public System.Collections.Generic.IReadOnlyList<HelpEntry> HelpEntries { get; }
            = new System.Collections.Generic.List<HelpEntry>
            {
                new HelpEntry("Up/Down", STRINGS.ONIACCESS.HELP.NAVIGATE),
                new HelpEntry("Escape", STRINGS.ONIACCESS.HELP.CLOSE),
                new HelpEntry("F12", STRINGS.ONIACCESS.HELP.CLOSE),
            }.AsReadOnly();

        public HelpHandler(System.Collections.Generic.IReadOnlyList<HelpEntry> entries)
        {
            _entries = entries ?? new System.Collections.Generic.List<HelpEntry>().AsReadOnly();
            _currentIndex = 0;
        }

        public bool HandleKeyDown(KButtonEvent e)
        {
            // Escape closes help -- Escape IS a game Action, so use TryConsume
            if (e.TryConsume(Action.Escape))
            {
                Close();
                return true;
            }
            // All other KButtonEvents are consumed by CapturesAllInput in ModInputRouter
            return false;
        }

        public bool HandleKeyUp(KButtonEvent e) => false;

        public bool HandleUnboundKey(UnityEngine.KeyCode keyCode)
        {
            switch (keyCode)
            {
                case UnityEngine.KeyCode.F12:
                    Close();
                    return true;
                case UnityEngine.KeyCode.DownArrow:
                    NavigateNext();
                    return true;
                case UnityEngine.KeyCode.UpArrow:
                    NavigatePrev();
                    return true;
                default:
                    return false;
            }
        }

        public void OnActivate()
        {
            // Speak "Help" then the first entry
            Speech.SpeechPipeline.SpeakInterrupt(DisplayName);
            if (_entries.Count > 0)
            {
                _currentIndex = 0;
                SpeakCurrentEntry();
            }
            else
            {
                Speech.SpeechPipeline.SpeakQueued(STRINGS.ONIACCESS.SPEECH.NO_COMMANDS);
            }
        }

        public void OnDeactivate()
        {
            _currentIndex = 0;
        }

        private void NavigateNext()
        {
            if (_entries.Count == 0) return;
            _currentIndex = (_currentIndex + 1) % _entries.Count;
            SpeakCurrentEntry();
        }

        private void NavigatePrev()
        {
            if (_entries.Count == 0) return;
            _currentIndex = (_currentIndex - 1 + _entries.Count) % _entries.Count;
            SpeakCurrentEntry();
        }

        private void SpeakCurrentEntry()
        {
            if (_currentIndex >= 0 && _currentIndex < _entries.Count)
            {
                Speech.SpeechPipeline.SpeakInterrupt(_entries[_currentIndex].ToString());
            }
        }

        private void Close()
        {
            HandlerStack.Pop();
        }
    }
}
```

**OniAccess/OniAccessStrings.cs:**
Add new LocString entries for handlers and help navigation. Keep existing SPEECH and HOTKEYS classes. Add:

```csharp
public class HANDLERS
{
    public static LocString WORLD_VIEW = "World view";
    public static LocString HELP = "Help";
}

public class HELP
{
    public static LocString NAVIGATE = "Step through help entries";
    public static LocString CLOSE = "Close help";
}
```

Add these inside the existing `ONIACCESS` class, alongside the existing `SPEECH` and `HOTKEYS` classes.
  </action>
  <verify>
Build with `dotnet build OniAccess/OniAccess.csproj` -- new files compile. Verify:
1. WorldHandler implements all IAccessHandler members
2. HelpHandler implements all IAccessHandler members
3. HelpHandler uses HandlerStack.Pop() to close (not Clear)
4. WorldHandler.HandleUnboundKey pushes HelpHandler with its own HelpEntries
5. OniAccessStrings has HANDLERS and HELP classes with LocString entries
  </verify>
  <done>
WorldHandler is the default world-view handler with F12 -> help. HelpHandler presents a navigable list with Up/Down/Escape. Both implement IAccessHandler fully. New LocString entries support handler display names and help navigation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Redesign VanillaMode, migrate Mod.cs, delete old Phase 1 input files</name>
  <files>
    OniAccess/Toggle/VanillaMode.cs
    OniAccess/Mod.cs
    OniAccess/Input/HotkeyRegistry.cs
    OniAccess/Input/InputInterceptor.cs
    OniAccess/Input/AccessContext.cs
  </files>
  <action>
Three parts: rewrite VanillaMode, update Mod.cs, delete old files.

**1. Rewrite OniAccess/Toggle/VanillaMode.cs:**
Per locked decisions:
- Toggle OFF: speak "Oni-Access off" THEN full disable (deactivate all handlers, stop speech, set flag). Speech must happen BEFORE disable.
- Toggle ON: set flag first, enable speech, speak "Oni-Access on", detect current state and activate handler. NO state dump.
- No background work when off.

```csharp
using OniAccess.Input;
using OniAccess.Speech;

namespace OniAccess.Toggle
{
    public static class VanillaMode
    {
        /// Whether the mod is currently enabled. Starts ON.
        public static bool IsEnabled { get; private set; } = true;

        /// Toggle the mod on or off. Called by KeyPoller on Ctrl+Shift+F12.
        public static void Toggle()
        {
            if (IsEnabled)
            {
                // Turning OFF
                // 1. Speak confirmation WHILE pipeline is still active
                SpeechPipeline.SpeakInterrupt(STRINGS.ONIACCESS.SPEECH.MOD_OFF);
                // 2. Deactivate all handlers (calls OnDeactivate on active, clears stack)
                HandlerStack.DeactivateAll();
                // 3. Disable speech pipeline (all subsequent calls are no-ops)
                SpeechPipeline.SetEnabled(false);
                // 4. Set flag last -- ModInputRouter checks this to pass all keys through
                IsEnabled = false;
            }
            else
            {
                // Turning ON
                // 1. Set flag first -- enables ModInputRouter and KeyPoller processing
                IsEnabled = true;
                // 2. Enable speech pipeline
                SpeechPipeline.SetEnabled(true);
                // 3. Speak confirmation only -- no state dump per locked decision
                SpeechPipeline.SpeakInterrupt(STRINGS.ONIACCESS.SPEECH.MOD_ON);
                // 4. Detect current game state and activate appropriate handler
                ContextDetector.DetectAndActivate();
            }
        }
    }
}
```

**2. Update OniAccess/Mod.cs:**
Replace Phase 1 input setup with Phase 2 system:

- REMOVE: `using OniAccess.Input;` is kept (new system is also in OniAccess.Input)
- REMOVE: The entire `RegisterHotkeys()` method (no more HotkeyRegistry calls)
- REMOVE: The `SpeakContextHelp()` method (help is now HelpHandler)
- REMOVE: The InputInterceptor GameObject creation
- ADD: KeyPoller GameObject creation (same pattern: persistent GO with DontDestroyOnLoad)
- ADD: After speech init, push initial WorldHandler onto HandlerStack
- KEEP: SpeechEngine.Initialize(), TextFilter.InitializeDefaults(), startup speech, RegisterForTranslation, Tolk DLL setup

Updated OnLoad flow:
```csharp
public override void OnLoad(Harmony harmony)
{
    Instance = this;
    ModDir = Path.GetDirectoryName(typeof(Mod).Assembly.Location);
    Version = typeof(Mod).Assembly.GetName().Version.ToString();

    string tolkDir = Path.Combine(ModDir, "tolk", "dist");
    if (!SetDllDirectory(tolkDir))
    {
        Log.Error($"Failed to set DLL directory to: {tolkDir}");
    }

    base.OnLoad(harmony);

    SpeechEngine.Initialize();
    TextFilter.InitializeDefaults();

    // Create persistent KeyPoller MonoBehaviour for unbound key detection
    // (F12, arrows -- keys ONI doesn't generate KButtonEvents for)
    var go = new GameObject("OniAccess_Input");
    UnityEngine.Object.DontDestroyOnLoad(go);
    go.AddComponent<Input.KeyPoller>();

    // Push initial WorldHandler -- the default "nothing special happening" handler
    // ModInputRouter will be registered later via Harmony patch on InputInit.Awake
    Input.HandlerStack.Push(new Input.WorldHandler());

    // Startup announcement
    SpeechPipeline.SpeakInterrupt(
        string.Format(STRINGS.ONIACCESS.SPEECH.MOD_LOADED, Version));

    Localization.RegisterForTranslation(typeof(STRINGS.ONIACCESS));

    Log.Info($"Oni-Access version {Version} loaded");
}
```

Note: Remove the `RegisterHotkeys` and `SpeakContextHelp` private methods entirely.

**3. Delete old Phase 1 input files:**
- DELETE `OniAccess/Input/HotkeyRegistry.cs` (replaced by per-handler key declarations in IAccessHandler)
- DELETE `OniAccess/Input/InputInterceptor.cs` (replaced by KeyPoller + ModInputRouter)
- DELETE `OniAccess/Input/AccessContext.cs` (replaced by handler stack -- the active handler IS the context)

These files are fully replaced by the 02-01 infrastructure. No code in the project should reference HotkeyRegistry, InputInterceptor, AccessContext, HotkeyModifier, or HotkeyBinding after this task.

Verify after deletion: `dotnet build` confirms no references to deleted types remain.
  </action>
  <verify>
1. `dotnet build OniAccess/OniAccess.csproj` succeeds -- no compile errors, no references to deleted types
2. Verify deleted files no longer exist: HotkeyRegistry.cs, InputInterceptor.cs, AccessContext.cs
3. Verify VanillaMode.Toggle() calls HandlerStack.DeactivateAll() on OFF and ContextDetector.DetectAndActivate() on ON
4. Verify Mod.cs creates KeyPoller (not InputInterceptor) and pushes WorldHandler (not RegisterHotkeys)
5. Grep project for "HotkeyRegistry", "InputInterceptor", "AccessContext", "HotkeyModifier", "HotkeyBinding" -- zero results
  </verify>
  <done>
VanillaMode fully deactivates/reactivates the handler stack. Mod.cs uses the new input system (KeyPoller + WorldHandler). All Phase 1 input files are deleted with zero remaining references. The mod's input system is completely migrated from flat registry to handler architecture. Build compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj` succeeds with zero errors and zero warnings about missing types
2. Full input flow: KeyPoller detects Ctrl+Shift+F12 -> VanillaMode.Toggle() -> HandlerStack.DeactivateAll/ContextDetector.DetectAndActivate
3. Full input flow: KeyPoller detects F12 -> WorldHandler.HandleUnboundKey -> HandlerStack.Push(HelpHandler) -> speaks first entry
4. Full input flow: HelpHandler receives Up/Down arrows -> navigates entries; Escape -> HandlerStack.Pop() -> returns to WorldHandler
5. Full input flow: Game key press -> ModInputRouter.OnKeyDown -> delegates to ActiveHandler or passes through
6. No references to deleted Phase 1 types (HotkeyRegistry, InputInterceptor, AccessContext, HotkeyModifier, HotkeyBinding)
7. VanillaMode OFF: speaks "off", deactivates all handlers, disables speech, sets IsEnabled=false
8. VanillaMode ON: sets IsEnabled=true, enables speech, speaks "on", detects state, activates handler
</verification>

<success_criteria>
- WorldHandler is the always-present default handler for world view
- HelpHandler presents a navigable list stepped through with Up/Down arrows
- VanillaMode fully disables/enables the entire handler stack
- Mod.cs migrated to new input system with no references to old Phase 1 code
- All old Phase 1 input files deleted
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-input-architecture/02-02-SUMMARY.md`
</output>
