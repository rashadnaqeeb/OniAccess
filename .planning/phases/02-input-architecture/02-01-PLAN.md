---
phase: 02-input-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - OniAccess/Input/IAccessHandler.cs
  - OniAccess/Input/HelpEntry.cs
  - OniAccess/Input/HandlerStack.cs
  - OniAccess/Input/ModInputRouter.cs
  - OniAccess/Input/KeyPoller.cs
  - OniAccess/Input/ContextDetector.cs
  - OniAccess/Patches/InputArchPatches.cs
autonomous: true

must_haves:
  truths:
    - "A single ModInputRouter is registered as a high-priority IInputHandler in ONI's KInputHandler tree and receives every KButtonEvent before PlayerController and KScreenManager"
    - "The HandlerStack manages IAccessHandler instances with push/pop/peek, and the active handler receives key events from the router"
    - "Context detection via Harmony patches on KScreen.Activate and KScreen.Deactivate fires callbacks that ContextDetector can use to switch handlers"
    - "A KeyPoller MonoBehaviour polls unbound keys (F12, arrow keys) and forwards them to the active handler, since ONI generates no KButtonEvent for these keys"
  artifacts:
    - path: "OniAccess/Input/IAccessHandler.cs"
      provides: "Interface for mod input handlers with DisplayName, CapturesAllInput, HandleKeyDown, HandleKeyUp, HelpEntries, OnActivate, OnDeactivate"
    - path: "OniAccess/Input/HelpEntry.cs"
      provides: "Simple data class for help list entries (key display name + description)"
    - path: "OniAccess/Input/HandlerStack.cs"
      provides: "Handler stack with Push, Pop, ActiveHandler, DeactivateAll, Clear"
    - path: "OniAccess/Input/ModInputRouter.cs"
      provides: "IInputHandler implementation that delegates to HandlerStack.ActiveHandler with full-capture and selective-claim modes"
    - path: "OniAccess/Input/KeyPoller.cs"
      provides: "MonoBehaviour polling Input.GetKeyDown for F12 and arrow keys, forwarding to active handler"
    - path: "OniAccess/Input/ContextDetector.cs"
      provides: "Static class tracking screen activations/deactivations and mapping them to handler switches"
    - path: "OniAccess/Patches/InputArchPatches.cs"
      provides: "Harmony patches: InputInit.Awake postfix for router registration, KScreen.Activate/Deactivate for context detection"
  key_links:
    - from: "OniAccess/Patches/InputArchPatches.cs"
      to: "OniAccess/Input/ModInputRouter.cs"
      via: "InputInit_Awake_Patch creates ModInputRouter and registers it at priority 50"
      pattern: "KInputHandler\\.Add.*ModInputRouter.*50"
    - from: "OniAccess/Input/ModInputRouter.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "OnKeyDown/OnKeyUp delegates to HandlerStack.ActiveHandler"
      pattern: "HandlerStack\\.ActiveHandler"
    - from: "OniAccess/Patches/InputArchPatches.cs"
      to: "OniAccess/Input/ContextDetector.cs"
      via: "KScreen_Activate_Patch and KScreen_Deactivate_Patch call ContextDetector methods"
      pattern: "ContextDetector\\.OnScreen"
    - from: "OniAccess/Input/KeyPoller.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "KeyPoller.Update polls unbound keys and calls ActiveHandler methods"
      pattern: "HandlerStack\\.ActiveHandler"
---

<objective>
Build the core input architecture that replaces Phase 1's MonoBehaviour+HotkeyRegistry approach with a proper handler system integrated into ONI's KInputHandler tree.

Purpose: This is the foundation for all context-sensitive input handling. ModInputRouter sits at priority 50 in ONI's input dispatch chain, receiving every KButtonEvent before the game's own handlers. It delegates to a stack of IAccessHandler instances, each of which declares what keys it claims. Context detection via KScreen lifecycle patches provides the signals for handler switching.

Output: 7 new files comprising the complete input infrastructure. No migration yet -- old files remain until Plan 02-02.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-input-architecture/02-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md

Phase 1 key decisions to honor:
- Always use System.Action (not Action) -- ONI's Action shadows it
- Always fully qualify UnityEngine.Input when in OniAccess.Input namespace
- UnityEngine.InputLegacyModule.dll already referenced in csproj
- Every plan must compile against game DLLs before being marked complete

Locked decisions from CONTEXT.md:
- Selective claim by default: each handler declares which keys it wants
- Full capture for menus: menu handlers block ALL keyboard input (except mouse events)
- Silent handling: no feedback about key "stealing"
- F12 opens a navigable list (arrow keys step through entries)
- VanillaMode toggle stays Ctrl+Shift+F12
- Mode announcements interrupt current speech (Phase 3+ convention, architecture must support it)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IAccessHandler interface, HelpEntry, and HandlerStack</name>
  <files>
    OniAccess/Input/IAccessHandler.cs
    OniAccess/Input/HelpEntry.cs
    OniAccess/Input/HandlerStack.cs
  </files>
  <action>
Create three files that define the handler contract and management:

**OniAccess/Input/IAccessHandler.cs:**
```csharp
namespace OniAccess.Input
{
    public interface IAccessHandler
    {
        /// Display name spoken on activation (e.g., "World view", "Build menu")
        /// Per locked decision: name first, vary early ("Build menu" not "Menu, build")
        string DisplayName { get; }

        /// Whether this handler captures ALL keyboard input (true for menus).
        /// When true, ModInputRouter consumes all keyboard KButtonEvents after the handler processes them,
        /// EXCEPT mouse actions (MouseLeft, MouseRight, MouseMiddle, ShiftMouseLeft, ZoomIn, ZoomOut).
        /// When false, only keys the handler explicitly consumes via e.TryConsume are blocked.
        bool CapturesAllInput { get; }

        /// Help entries for F12 navigable help list. Each handler owns its help text.
        System.Collections.Generic.IReadOnlyList<HelpEntry> HelpEntries { get; }

        /// Process a key down event from ONI's KButtonEvent system.
        /// Call e.TryConsume(Action.X) to claim a game-mapped key.
        /// Set e.Consumed = true to claim an unmapped key.
        /// Return true if the event was consumed.
        bool HandleKeyDown(KButtonEvent e);

        /// Process a key up event. Same consumption rules as HandleKeyDown.
        bool HandleKeyUp(KButtonEvent e);

        /// Called by KeyPoller for keys that have no KButtonEvent (F12, arrows).
        /// keyCode is the UnityEngine.KeyCode that was pressed.
        /// Return true if handled.
        bool HandleUnboundKey(UnityEngine.KeyCode keyCode);

        /// Called when this handler becomes the active handler on the stack.
        /// Per locked decision: speak DisplayName here (interrupts current speech).
        void OnActivate();

        /// Called when this handler is removed from the active position.
        void OnDeactivate();
    }
}
```

**OniAccess/Input/HelpEntry.cs:**
```csharp
namespace OniAccess.Input
{
    /// Simple data class for help list entries.
    /// Each handler provides its own list of these.
    public sealed class HelpEntry
    {
        public string KeyName { get; }
        public string Description { get; }

        public HelpEntry(string keyName, string description)
        {
            KeyName = keyName;
            Description = description;
        }

        public override string ToString() => $"{KeyName}: {Description}";
    }
}
```

**OniAccess/Input/HandlerStack.cs:**
A static class managing a `List<IAccessHandler>` as a stack (last element = active):

- `ActiveHandler` property: returns top of stack or null
- `Push(IAccessHandler handler)`: adds handler, calls handler.OnActivate(). If there was a previous active handler, does NOT call its OnDeactivate (it's just obscured, not removed -- it will become active again when the top is popped).
- `Pop()`: removes top handler, calls its OnDeactivate(). If a handler is now exposed underneath, calls its OnActivate().
- `Replace(IAccessHandler handler)`: pops current (calling OnDeactivate), then pushes new (calling OnActivate). Used by ContextDetector when switching between same-level handlers (e.g., WorldHandler to MenuHandler).
- `DeactivateAll()`: calls OnDeactivate on active handler only, then clears the entire stack. Used by VanillaMode toggle OFF.
- `Clear()`: clears without calling any callbacks. Used for emergency cleanup.
- `Count` property for debugging.

Important: All methods must be safe for null/empty stack (no exceptions). Use `OniAccess.Util.Log` for debug logging.
  </action>
  <verify>
Build with `dotnet build OniAccess/OniAccess.csproj` -- all three files compile without errors. Verify IAccessHandler references KButtonEvent (from Assembly-CSharp-firstpass), HelpEntry, and UnityEngine.KeyCode. Verify HandlerStack calls OnActivate/OnDeactivate in the correct order.
  </verify>
  <done>
IAccessHandler interface defines the full handler contract. HelpEntry is a simple value type. HandlerStack manages a list-based stack with proper activate/deactivate lifecycle callbacks. All three compile against game DLLs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ModInputRouter, KeyPoller, ContextDetector, and Harmony patches</name>
  <files>
    OniAccess/Input/ModInputRouter.cs
    OniAccess/Input/KeyPoller.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/Patches/InputArchPatches.cs
  </files>
  <action>
Create four files that integrate the handler system into ONI's input pipeline:

**OniAccess/Input/ModInputRouter.cs:**
Implements `IInputHandler` (from Assembly-CSharp-firstpass). This is the single entry point into ONI's KInputHandler tree.

```csharp
namespace OniAccess.Input
{
    public class ModInputRouter : IInputHandler
    {
        public static ModInputRouter Instance { get; private set; }

        public string handlerName => "OniAccess";
        public KInputHandler inputHandler { get; set; }

        public ModInputRouter() { Instance = this; }

        public void OnKeyDown(KButtonEvent e)
        {
            if (e.Consumed) return;

            // When mod is off, pass everything through
            if (!Toggle.VanillaMode.IsEnabled) return;

            var handler = HandlerStack.ActiveHandler;
            if (handler == null) return;

            if (handler.CapturesAllInput)
            {
                // Full capture: handler processes first, then consume all non-mouse events
                handler.HandleKeyDown(e);
                if (!e.Consumed)
                {
                    // Let mouse and zoom actions through
                    // Check if this is a mouse/zoom action -- if so, don't consume
                    if (!IsMouseOrZoomAction(e))
                    {
                        e.Consumed = true;
                    }
                }
            }
            else
            {
                // Selective: handler decides what to consume via e.TryConsume
                handler.HandleKeyDown(e);
            }
        }

        public void OnKeyUp(KButtonEvent e)
        {
            if (e.Consumed || !Toggle.VanillaMode.IsEnabled) return;

            var handler = HandlerStack.ActiveHandler;
            if (handler == null) return;

            if (handler.CapturesAllInput)
            {
                handler.HandleKeyUp(e);
                if (!e.Consumed && !IsMouseOrZoomAction(e))
                {
                    e.Consumed = true;
                }
            }
            else
            {
                handler.HandleKeyUp(e);
            }
        }

        /// Check if the event is a mouse or zoom action that should pass through
        /// even in full-capture mode. Per pitfall #6: full capture must not block mouse.
        private static bool IsMouseOrZoomAction(KButtonEvent e)
        {
            // KButtonEvent has IsAction method -- check known mouse/zoom actions
            return e.IsAction(Action.MouseLeft) || e.IsAction(Action.MouseRight)
                || e.IsAction(Action.MouseMiddle) || e.IsAction(Action.ShiftMouseLeft)
                || e.IsAction(Action.ZoomIn) || e.IsAction(Action.ZoomOut);
        }
    }
}
```

NOTE: `Action` here is ONI's `Action` enum (not System.Action). It's in the global namespace from Assembly-CSharp-firstpass. Since this file is in `OniAccess.Input` namespace, `Action` resolves to the ONI enum (there's no conflict here because we're not using System.Action as a type name in this file). But if we need System.Action, use `System.Action` explicitly.

**OniAccess/Input/KeyPoller.cs:**
MonoBehaviour that polls `UnityEngine.Input.GetKeyDown` for keys that ONI doesn't generate KButtonEvents for. Per research: plain F12 (no modifiers) and arrow keys have NO Action binding, so no KButtonEvent is ever created for them.

```csharp
namespace OniAccess.Input
{
    public class KeyPoller : UnityEngine.MonoBehaviour
    {
        public static KeyPoller Instance { get; private set; }

        // Keys to poll -- these have no ONI Action binding
        private static readonly UnityEngine.KeyCode[] PollKeys = new[]
        {
            UnityEngine.KeyCode.F12,
            UnityEngine.KeyCode.UpArrow,
            UnityEngine.KeyCode.DownArrow,
            UnityEngine.KeyCode.LeftArrow,
            UnityEngine.KeyCode.RightArrow,
        };

        private void Awake() { Instance = this; }

        private void Update()
        {
            // Toggle key: Ctrl+Shift+F12 -- ALWAYS check, even when mod is off
            // This is the only key that works when mod is disabled
            if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.F12)
                && IsCtrlShiftHeld())
            {
                Toggle.VanillaMode.Toggle();
                return; // Don't process F12 further this frame
            }

            // When mod is off, don't process anything else
            if (!Toggle.VanillaMode.IsEnabled) return;

            var handler = HandlerStack.ActiveHandler;
            if (handler == null) return;

            // Poll each unbound key
            foreach (var key in PollKeys)
            {
                if (UnityEngine.Input.GetKeyDown(key))
                {
                    // Skip F12 if modifiers are held (those ARE bound to game actions
                    // and will come through as KButtonEvents via ModInputRouter)
                    if (key == UnityEngine.KeyCode.F12 && AnyModifierHeld()) continue;

                    handler.HandleUnboundKey(key);
                }
            }
        }

        private static bool IsCtrlShiftHeld()
        {
            return (UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftControl)
                    || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightControl))
                && (UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftShift)
                    || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightShift));
        }

        private static bool AnyModifierHeld()
        {
            return UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftControl)
                || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightControl)
                || UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftShift)
                || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightShift)
                || UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftAlt)
                || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightAlt);
        }

        private void OnDestroy()
        {
            if (Instance == this) Instance = null;
        }
    }
}
```

**OniAccess/Input/ContextDetector.cs:**
Static class that receives screen lifecycle events from Harmony patches and determines which handler to activate. Phase 2 implements a minimal mapping -- just "any KScreen activates = something is open" vs "nothing active = world view." Phase 3 will add specific screen mappings.

```csharp
namespace OniAccess.Input
{
    public static class ContextDetector
    {
        /// Called from Harmony postfix on KScreen.Activate.
        /// Phase 2: log the activation for debugging. Phase 3 will map specific screens to handlers.
        public static void OnScreenActivated(KScreen screen)
        {
            if (screen == null) return;
            Util.Log.Debug($"Screen activated: {screen.GetType().Name}");
            // Phase 3 will add: determine handler from screen type, push/replace on HandlerStack
        }

        /// Called from Harmony prefix on KScreen.Deactivate.
        /// Phase 2: log the deactivation. Phase 3 will pop/switch handlers.
        public static void OnScreenDeactivating(KScreen screen)
        {
            if (screen == null) return;
            Util.Log.Debug($"Screen deactivating: {screen.GetType().Name}");
            // Phase 3 will add: pop handler if this screen's handler is on top of stack
        }

        /// Detect current game state and activate the appropriate handler.
        /// Called when mod is toggled ON to determine what handler should be active.
        /// Phase 2: pushes WorldHandler as the default.
        /// Phase 3 will examine KScreenManager.Instance.screenStack for open screens.
        public static void DetectAndActivate()
        {
            // Phase 2: always push WorldHandler as default
            // Phase 3 will add: check screen stack for open menus, push appropriate handler
            HandlerStack.Replace(new WorldHandler());
        }
    }
}
```

**OniAccess/Patches/InputArchPatches.cs:**
Harmony patches for integrating into ONI's input system:

1. `InputInit_Awake_Patch` (Postfix): Creates ModInputRouter, registers at priority 50 in KInputHandler tree. Must be idempotent (check if already registered). Per research: use `Global.GetInputManager().GetDefaultController()` or `KInputManager.currentController`.

2. `KScreen_Activate_Patch` (Postfix): Calls `ContextDetector.OnScreenActivated(__instance)` when VanillaMode is enabled.

3. `KScreen_Deactivate_Patch` (Prefix): Calls `ContextDetector.OnScreenDeactivating(__instance)` when VanillaMode is enabled. Must be Prefix because Deactivate() calls PopScreen then Destroy.

For InputInit_Awake_Patch registration:
```csharp
[HarmonyPatch(typeof(InputInit), "Awake")]
static class InputInit_Awake_Patch
{
    static void Postfix()
    {
        // Idempotent: don't register twice
        if (ModInputRouter.Instance != null) return;

        var router = new ModInputRouter();
        var controller = Global.GetInputManager().GetDefaultController();
        // Priority 50: above PlayerController (20), KScreenManager (10), CameraController (1)
        controller.inputHandler.AddInputHandler(router);
        // Note: AddInputHandler signature is AddInputHandler(IInputHandler handler)
        // The priority is set via KInputHandler constructor that wraps the IInputHandler.
        // Actually, from research: KInputHandler.Add(KInputHandler parent, IInputHandler handler, int priority)
        // is the static method. Let's use that:
        // KInputHandler.Add(controller.inputHandler, router, 50);

        Util.Log.Info("ModInputRouter registered at priority 50");
    }
}
```

IMPORTANT: Verify the exact API for registering an IInputHandler with a priority in the game DLLs. The research says `KInputHandler.Add(parent, handler, priority)` -- the executor must verify this matches the actual decompiled signature. If the static method doesn't exist, use `parent.AddInputHandler(handler)` and find the priority parameter. Check `ONI-Decompiled/Assembly-CSharp-firstpass/KInputHandler.cs` for the exact method signature.

Also keep the existing `Game_OnDestroy_Patch` in `InputPatches.cs` (renamed file stays separate). The new patches go in `InputArchPatches.cs`.
  </action>
  <verify>
Build with `dotnet build OniAccess/OniAccess.csproj` -- all four new files compile without errors alongside existing files. Verify:
1. ModInputRouter implements IInputHandler (handlerName, inputHandler properties, OnKeyDown/OnKeyUp methods)
2. InputArchPatches references InputInit, KScreen, KInputHandler correctly
3. KeyPoller uses fully qualified UnityEngine.Input (not bare Input)
4. No use of bare `Action` where `System.Action` is intended
  </verify>
  <done>
ModInputRouter is a valid IInputHandler registered at priority 50 in ONI's handler tree. KeyPoller polls unbound keys (F12, arrows) and forwards to active handler. ContextDetector provides screen lifecycle hooks for Phase 3 to build on. Harmony patches integrate everything at game startup and screen transitions. All files compile against game DLLs.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj` succeeds with no errors (all 7 new files + existing files compile together)
2. IAccessHandler interface has: DisplayName, CapturesAllInput, HelpEntries, HandleKeyDown, HandleKeyUp, HandleUnboundKey, OnActivate, OnDeactivate
3. ModInputRouter implements IInputHandler with handlerName="OniAccess" and delegates to HandlerStack.ActiveHandler
4. KeyPoller checks Ctrl+Shift+F12 toggle even when mod is off, only polls other keys when mod is on
5. InputArchPatches contains [HarmonyPatch] attributes for InputInit.Awake, KScreen.Activate, KScreen.Deactivate
6. No bare `Action` used where `System.Action` is intended (ONI's Action enum is fine in event handler code)
7. All UnityEngine.Input references are fully qualified
</verification>

<success_criteria>
- 7 new source files created in OniAccess/Input/ and OniAccess/Patches/
- Project compiles cleanly against game DLLs
- ModInputRouter registered in ONI's KInputHandler tree at priority 50 (above all game handlers)
- Handler stack supports push/pop/replace with proper OnActivate/OnDeactivate lifecycle
- Unbound keys (F12, arrows) polled via KeyPoller and forwarded to active handler
- Context detection skeleton ready for Phase 3 to add screen-specific handler mappings
</success_criteria>

<output>
After completion, create `.planning/phases/02-input-architecture/02-01-SUMMARY.md`
</output>
