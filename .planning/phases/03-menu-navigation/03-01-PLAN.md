---
phase: 03-menu-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - OniAccess/Input/BaseMenuHandler.cs
  - OniAccess/Input/WidgetInfo.cs
  - OniAccess/Input/ISearchable.cs
  - OniAccess/Input/TypeAheadSearch.cs
  - OniAccess/Input/KeyPoller.cs
  - OniAccess/Input/ContextDetector.cs
autonomous: true

must_haves:
  truths:
    - "BaseMenuHandler provides arrow navigation with wrap-around, Home/End, Enter activation, focus tracking, speech queuing on entry, and type-ahead search integration"
    - "TypeAheadSearch and ISearchable are ported into OniAccess namespace with dependencies on SpeechPipeline instead of external Speech class"
    - "KeyPoller polls Home, End, Tab, and Return keys alongside existing F12 and arrow keys"
    - "ContextDetector has a registry mechanism that maps screen types to handler factories and pushes/pops handlers on HandlerStack"
    - "WidgetInfo captures label, component reference, widget type, and GameObject for any interactive widget"
  artifacts:
    - path: "OniAccess/Input/BaseMenuHandler.cs"
      provides: "Abstract base class for all menu screen handlers"
      contains: "abstract class BaseMenuHandler"
    - path: "OniAccess/Input/WidgetInfo.cs"
      provides: "Widget metadata and WidgetType enum"
      contains: "enum WidgetType"
    - path: "OniAccess/Input/ISearchable.cs"
      provides: "Interface for type-ahead search integration"
      contains: "interface ISearchable"
    - path: "OniAccess/Input/TypeAheadSearch.cs"
      provides: "Type-ahead search with word-start matching and same-letter cycling"
      contains: "class TypeAheadSearch"
    - path: "OniAccess/Input/ContextDetector.cs"
      provides: "Screen-to-handler registry with push/pop lifecycle"
      contains: "_registry"
  key_links:
    - from: "OniAccess/Input/BaseMenuHandler.cs"
      to: "OniAccess/Input/IAccessHandler.cs"
      via: "implements IAccessHandler"
      pattern: "IAccessHandler"
    - from: "OniAccess/Input/BaseMenuHandler.cs"
      to: "OniAccess/Input/TypeAheadSearch.cs"
      via: "holds TypeAheadSearch instance for A-Z search"
      pattern: "TypeAheadSearch"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "Push/Pop handlers when screens activate/deactivate"
      pattern: "HandlerStack\\.Push|HandlerStack\\.Pop"
    - from: "OniAccess/Input/TypeAheadSearch.cs"
      to: "OniAccess/Speech/SpeechPipeline.cs"
      via: "SpeakInterrupt for search announcements"
      pattern: "SpeechPipeline\\.SpeakInterrupt"
---

<objective>
Build the generic KScreen accessibility infrastructure that all menu screen handlers inherit from. This is the reusable foundation for Phases 3, 7, 8, and 12.

Purpose: Eliminate boilerplate across dozens of screen handlers by providing arrow navigation with wrap, Home/End, Enter activation, focus tracking, type-ahead search, and speech queuing in an abstract base class. Port the existing TypeAheadSearch class. Extend KeyPoller for menu-needed keys. Wire ContextDetector to push/pop handlers on screen lifecycle events.

Output: BaseMenuHandler abstract class, WidgetInfo/WidgetType data types, ISearchable interface, TypeAheadSearch class, updated KeyPoller and ContextDetector.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-menu-navigation/03-RESEARCH.md
@OniAccess/Input/IAccessHandler.cs
@OniAccess/Input/HandlerStack.cs
@OniAccess/Input/ContextDetector.cs
@OniAccess/Input/KeyPoller.cs
@OniAccess/Input/HelpHandler.cs
@OniAccess/Input/WorldHandler.cs
@OniAccess/Input/ModInputRouter.cs
@OniAccess/Speech/SpeechPipeline.cs
@OniAccess/Input/HelpEntry.cs
@OniAccess/OniAccessStrings.cs
@TypeAheadSearch.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WidgetInfo, ISearchable, and TypeAheadSearch port</name>
  <files>
    OniAccess/Input/WidgetInfo.cs
    OniAccess/Input/ISearchable.cs
    OniAccess/Input/TypeAheadSearch.cs
  </files>
  <action>
Create three new files in OniAccess/Input/:

**WidgetInfo.cs** -- Data class and enum for widget metadata:
- `WidgetType` enum: `Button`, `Toggle`, `Slider`, `Dropdown`, `Label`, `TextInput`
- `WidgetInfo` class with properties:
  - `string Label` -- speakable text for the widget
  - `UnityEngine.Component Component` -- the KButton/KToggle/KSlider/etc reference
  - `WidgetType Type` -- what kind of widget this is
  - `UnityEngine.GameObject GameObject` -- the widget's GameObject (for tooltip access)
- Namespace: `OniAccess.Input`

**ISearchable.cs** -- Port from repo-root TypeAheadSearch.cs `ISearchable` interface:
- Keep same 4 members: `SearchItemCount`, `SearchCurrentIndex`, `GetSearchLabel(int)`, `SearchMoveTo(int)`
- Change namespace from `UnityKeyNav` to `OniAccess.Input`
- Keep all XML doc comments

**TypeAheadSearch.cs** -- Port from repo-root TypeAheadSearch.cs:
- Change namespace from `UnityKeyNav` to `OniAccess.Input`
- Replace all `Speech.Say(...)` calls with `OniAccess.Speech.SpeechPipeline.SpeakInterrupt(...)` -- search results should interrupt (per decision: value changes use SpeakInterrupt for rapid adjustment)
- Remove `InputBlocker.BlockCancelOnce = true` line (that's from another project; ONI handles Escape differently)
- Remove `NavigationUtils.WrapIndex` call -- inline the wrap logic: `(_resultCursor + direction % count + count) % count` or use a simple modulo wrap
- Keep all the search logic intact: AddChar, RemoveChar, Clear, Search, NavigateResults, HandleKey, word-start matching, same-letter cycling, buffer timeout
- The `HandleKey` method signature uses `KeyboardManager.KeyModifiers` -- replace this with two bool parameters: `bool ctrlHeld, bool altHeld` since we don't have that type. Update the modifier checks accordingly (replace `modifiers.Control` with `ctrlHeld`, `modifiers.Alt` with `altHeld`)
- Keep `Time.time` for timeout (fully qualify as `UnityEngine.Time.time` per project convention)
- Keep all working-list swap optimization for zero-allocation search

All files must use `System.Action` (not bare `Action`) per project decision.
  </action>
  <verify>
Build the project: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed with no errors.
  </verify>
  <done>
WidgetInfo.cs defines WidgetType enum and WidgetInfo class. ISearchable.cs defines the search interface. TypeAheadSearch.cs is a working port with SpeechPipeline integration and no external dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: BaseMenuHandler abstract class</name>
  <files>
    OniAccess/Input/BaseMenuHandler.cs
  </files>
  <action>
Create `OniAccess/Input/BaseMenuHandler.cs` -- abstract class implementing `IAccessHandler`:

**State:**
- `protected readonly List<WidgetInfo> _widgets = new List<WidgetInfo>()`
- `protected int _currentIndex`
- `protected KScreen _screen` -- the KScreen instance this handler manages
- `protected readonly TypeAheadSearch _search = new TypeAheadSearch()`
- Constructor takes `KScreen screen`, stores it in `_screen`

**Abstract members (subclasses MUST implement):**
- `abstract string DisplayName { get; }`
- `abstract IReadOnlyList<HelpEntry> HelpEntries { get; }`
- `abstract void DiscoverWidgets(KScreen screen)` -- each subclass enumerates its screen's interactive widgets into `_widgets`

**IAccessHandler implementation:**
- `bool CapturesAllInput => true` -- all menu handlers capture input (per research: modal screens consume all input)
- `virtual void OnActivate()`:
  1. Call `DiscoverWidgets(_screen)` to populate `_widgets`
  2. `SpeechPipeline.SpeakInterrupt(DisplayName)` -- screen name announced
  3. `_currentIndex = 0`
  4. If `_widgets.Count > 0`: `SpeechPipeline.SpeakQueued(GetWidgetSpeechText(_widgets[0]))` -- first widget queued behind title (per decision: same pattern as HelpHandler)
  5. `_search.Clear()` -- reset search state on entry
- `virtual void OnDeactivate()`: `_currentIndex = 0; _search.Clear()`

**HandleUnboundKey(KeyCode keyCode):**
- `KeyCode.DownArrow` -> `NavigateNext()`; return true
- `KeyCode.UpArrow` -> `NavigatePrev()`; return true
- `KeyCode.Home` -> `NavigateFirst()`; return true
- `KeyCode.End` -> `NavigateLast()`; return true
- `KeyCode.Return` -> `ActivateCurrentWidget()`; return true
- `KeyCode.Tab` -> (if Shift held: navigate tabs backward, else forward) -- call `virtual void NavigateTabForward()` and `NavigateTabBackward()`. Default implementations are no-ops (not all screens have tabs). Check Shift via `UnityEngine.Input.GetKey(KeyCode.LeftShift) || UnityEngine.Input.GetKey(KeyCode.RightShift)`
- `KeyCode.LeftArrow` -> `AdjustCurrentWidget(-1, isLargeStep: false)`; return true (only if current widget is slider/dropdown; for buttons, return false or let it no-op)
- `KeyCode.RightArrow` -> `AdjustCurrentWidget(1, isLargeStep: false)`; return true (same)
- Check Shift+Left/Right for large step: if `UnityEngine.Input.GetKey(LeftShift/RightShift)` is true AND key is LeftArrow/RightArrow, call `AdjustCurrentWidget` with `isLargeStep: true`
- Default: return false

**HandleKeyDown(KButtonEvent e):**
- Check for Shift+I (tooltip reading): if `e.Controller.GetKeyDown(KKeyCode.I)` and Shift is held -> call `SpeakTooltip()`; `e.Consumed = true`; return true
- Check for A-Z keys for type-ahead search: iterate KKeyCode.A through KKeyCode.Z. If `e.Controller.GetKeyDown(kk)` for any letter, determine ctrlHeld and altHeld from `UnityEngine.Input.GetKey`. Call `_search.HandleKey(keyCode, ctrlHeld, altHeld, this)` (where `this` implements ISearchable -- see below). If HandleKey returns true, consume the event
- Check for Escape: `e.TryConsume(Action.Escape)` -- do NOT handle Escape ourselves. Per decision: Escape triggers the game's own close behavior. Return false to let the event through to the game's KScreen.OnKeyDown which handles close. Actually since CapturesAllInput is true, the event won't reach the game. So for Escape: explicitly do NOT consume it. Instead, return false so ModInputRouter's CapturesAllInput logic blocks non-mouse keys. But wait -- Escape needs to reach the game screen to close it. Solution: for Escape specifically, do NOT consume the event AND set a flag or handle it specially. Actually, rethinking: ModInputRouter walks the handler stack. If our handler doesn't consume Escape, and CapturesAllInput is true, ModInputRouter blocks it. The game screen never sees it. So we MUST let Escape through. Options: (a) Don't block Escape in CapturesAllInput. (b) Have the handler explicitly pass Escape through. Best approach: in HandleKeyDown, if the event is Escape (`e.IsAction(Action.Escape)`), return false WITHOUT consuming. Then in ModInputRouter, Escape needs special treatment like mouse actions. OR: simpler -- override `CapturesAllInput` handling. Actually, the cleanest solution per the existing architecture: ModInputRouter already passes through mouse/zoom actions. Add `Action.Escape` to the pass-through list in `ModInputRouter.IsMouseOrZoomAction` (rename to `IsPassThroughAction`). This way, when a menu handler doesn't consume Escape, it passes through to the game's screen handler which closes the screen, which triggers our KScreen.Deactivate patch, which pops our handler. This is the correct flow per the locked decision "Escape triggers the game's own close behavior."

  So: add `Action.Escape` to the pass-through check in ModInputRouter.cs. Rename `IsMouseOrZoomAction` to `IsPassThroughAction`. Add `|| e.IsAction(Action.Escape)` to the check.

- For F12: handled via HandleUnboundKey (KeyPoller), not here
- Default: return false (let CapturesAllInput block non-mouse, non-Escape keys)

**HandleKeyUp:** return false (no key-up handling needed)

**ISearchable implementation** (BaseMenuHandler implements ISearchable):
- `SearchItemCount => _widgets.Count`
- `SearchCurrentIndex => _currentIndex`
- `GetSearchLabel(int index) => index >= 0 && index < _widgets.Count ? _widgets[index].Label : null`
- `SearchMoveTo(int index)`: set `_currentIndex = index`; call `SpeakCurrentWidget()`

**Navigation methods (protected):**
- `NavigateNext()`: if `_widgets.Count == 0` return. `_currentIndex = (_currentIndex + 1) % _widgets.Count`. If wrapped to 0, call `PlayWrapSound()`. Call `SpeakCurrentWidget()`.
- `NavigatePrev()`: if `_widgets.Count == 0` return. Decrement with wrap. If wrapped to last, call `PlayWrapSound()`. Call `SpeakCurrentWidget()`.
- `NavigateFirst()`: `_currentIndex = 0; SpeakCurrentWidget()`
- `NavigateLast()`: `_currentIndex = _widgets.Count - 1; SpeakCurrentWidget()`

**Widget interaction methods (protected virtual):**
- `virtual string GetWidgetSpeechText(WidgetInfo widget)`: Returns "label, value" for widgets with values (slider, toggle, dropdown) or just "label" for buttons/labels. Per decision: no type announcement. For toggles: "label, on/off". For sliders: "label, formatted_value". For dropdowns: "label, current_option". Default implementation returns `widget.Label`.
- `virtual void ActivateCurrentWidget()`: if no widgets, return. Get current widget. Based on Type:
  - Button: `(widget.Component as KButton)?.SignalClick(KKeyCode.Mouse0)` -- this triggers the game's onClick AND plays the button sound naturally
  - Toggle: `(widget.Component as KToggle)?.Click()` then speak new state via SpeakInterrupt: "label, on/off"
  - TextInput: no-op in base (subclasses handle text editing)
  - Other: no-op
- `virtual void AdjustCurrentWidget(int direction, bool isLargeStep)`: Based on widget Type:
  - Slider: get `KSlider`. Calculate step: if `slider.wholeNumbers`, step = isLargeStep ? 10 : 1. If not wholeNumbers, range = max-min, step = isLargeStep ? range*0.1f : range*0.01f. Set `slider.value = Mathf.Clamp(slider.value + step * direction, slider.minValue, slider.maxValue)`. Speak via SpeakInterrupt: "label, formatted_value". Per decision: SpeakInterrupt for rapid adjustment.
  - Dropdown: call `virtual void CycleDropdown(WidgetInfo widget, int direction)` -- default no-op, subclasses implement per their dropdown type
  - Other types: no-op

**Utility methods (protected):**
- `SpeakCurrentWidget()`: if valid index, `SpeechPipeline.SpeakInterrupt(GetWidgetSpeechText(_widgets[_currentIndex]))`
- `PlayWrapSound()`: `KFMOD.PlayUISound(GlobalAssets.GetSound("HUD_Click_Close"))` -- per discretion recommendation. Wrap in try/catch in case sound name doesn't exist.
- `SpeakTooltip()`: get current widget's GameObject. `var tooltip = widget.GameObject.GetComponent<ToolTip>()`. If null, return. Try `tooltip.GetMultiString(0)`. If empty, return. `SpeechPipeline.SpeakInterrupt(filtered_text)`.
- `FormatSliderValue(KSlider slider)`: if wholeNumbers, return `((int)slider.value).ToString()`. Otherwise, use `GameUtil.GetFormattedPercent(slider.value)` if it looks like a 0-100 percent, or just `slider.value.ToString("F1")`.

**ModInputRouter.cs modification:**
- Rename `IsMouseOrZoomAction` to `IsPassThroughAction` in both OnKeyDown and OnKeyUp methods
- Add `|| e.IsAction(Action.Escape)` to the check body

**F12 help in BaseMenuHandler:**
- In `HandleUnboundKey`, if `keyCode == KeyCode.F12`: push HelpHandler with this handler's HelpEntries (same pattern as WorldHandler). Return true.
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify BaseMenuHandler compiles with all abstract/virtual methods, ISearchable implementation, and IAccessHandler implementation.
  </verify>
  <done>
BaseMenuHandler abstract class exists with full arrow navigation, wrap-around with earcon, Home/End, Enter activation, Tab stubs, Shift+I tooltip, F12 help, type-ahead search via ISearchable, slider step-size logic (per discretion: wholeNumbers-based), and Escape pass-through in ModInputRouter. A concrete subclass only needs to implement DiscoverWidgets, DisplayName, and HelpEntries.
  </done>
</task>

<task type="auto">
  <name>Task 3: KeyPoller extensions and ContextDetector registry</name>
  <files>
    OniAccess/Input/KeyPoller.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/Input/ModInputRouter.cs
  </files>
  <action>
**KeyPoller.cs** -- Add new keys to the PollKeys array:
- Add `KeyCode.Home`, `KeyCode.End`, `KeyCode.Tab`, `KeyCode.Return` to the `PollKeys` array
- These keys have no ONI Action binding per research, so they must be polled
- Keep existing keys: F12, UpArrow, DownArrow, LeftArrow, RightArrow
- No other changes needed -- the existing dispatch via `HandlerStack.DispatchUnboundKey(key)` already routes to BaseMenuHandler.HandleUnboundKey

**ContextDetector.cs** -- Rewrite to add registry mechanism:
- Add `private static readonly Dictionary<System.Type, System.Func<KScreen, IAccessHandler>> _registry = new Dictionary<System.Type, System.Func<KScreen, IAccessHandler>>()`
- Add `public static void Register<TScreen>(System.Func<KScreen, IAccessHandler> factory) where TScreen : KScreen` -- adds `typeof(TScreen)` -> factory mapping. Called during mod init or lazily.
- Add `public static void Register(System.Type screenType, System.Func<KScreen, IAccessHandler> factory)` -- non-generic overload for when type is only known at runtime (e.g., internal types resolved via AccessTools.TypeByName)
- Rewrite `OnScreenActivated(KScreen screen)`:
  1. If screen is null, return
  2. Get `screen.GetType()`
  3. Look up in `_registry`. If not found, log debug and return (unregistered screens are silently ignored -- they're structural UI like FrontEndBackground)
  4. Create handler via factory: `var handler = factory(screen)`
  5. Check if current active handler is a BaseMenuHandler whose `_screen` matches a PARENT screen relationship. If so, use `HandlerStack.Replace(handler)` instead of Push. This handles child screens (e.g., OptionsMenuScreen -> AudioOptionsScreen per Pitfall 1). Determining parent relationship: if the current handler's screen is the one that activated this new screen. Simplest check: if current handler is a BaseMenuHandler, Replace. If current handler is NOT a BaseMenuHandler (e.g., WorldHandler), Push.
  6. Actually, simpler and more robust: always Push. The deactivate logic will pop correctly because when a parent screen hides (not deactivates) and a child activates, the parent's Deactivate is NOT called. When the child deactivates, our patch pops the child handler, re-exposing the parent handler. If the parent screen IS deactivated (like Options -> Audio Options where Options hides), then both handlers would be on the stack but that's fine -- the child is on top. When child closes, parent may or may not reactivate. Test in-game. For now: always Push. Simplest correct behavior.
  7. `HandlerStack.Push(handler)`
- Rewrite `OnScreenDeactivating(KScreen screen)`:
  1. If screen is null, return
  2. Get active handler from `HandlerStack.ActiveHandler`
  3. If active handler is a `BaseMenuHandler` and its `Screen` property == screen, call `HandlerStack.Pop()`. This correctly pops only if the deactivating screen matches the top handler's screen.
  4. If active handler doesn't match (screen deactivating is not the top handler's screen), log debug and do nothing. This handles cases where structural screens deactivate without having handlers.
- Rewrite `DetectAndActivate()`:
  1. Log the call
  2. Check `KScreenManager.Instance` and its screen stack for any open registered screens
  3. If a registered screen is found, create and push its handler
  4. If no registered screen is found (or we're in the main menu), push WorldHandler as baseline
  5. For now, keep the simple "push WorldHandler" behavior -- the screen lifecycle patches will handle menu detection automatically when screens activate

Add a `public KScreen Screen => _screen` property to BaseMenuHandler so ContextDetector can check which screen a handler belongs to.

**ModInputRouter.cs** changes (if not already done in Task 2 -- if Task 2 already modifies this file, consolidate here):
- Rename `IsMouseOrZoomAction` to `IsPassThroughAction`
- Add `|| e.IsAction(Action.Escape)` to the pass-through check
- Update both call sites in OnKeyDown and OnKeyUp
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify KeyPoller has 9 poll keys. Verify ContextDetector has Register method and Push/Pop logic.
  </verify>
  <done>
KeyPoller polls Home, End, Tab, Return in addition to existing keys. ContextDetector has a type-safe registry with Push on activate and Pop on deactivate. ModInputRouter passes Escape through to game screens. The infrastructure is ready for concrete screen handlers.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj -c Release` -- clean build, no errors, no warnings about missing types
2. Verify BaseMenuHandler implements all IAccessHandler members
3. Verify BaseMenuHandler implements ISearchable
4. Verify TypeAheadSearch uses SpeechPipeline (not external Speech class)
5. Verify KeyPoller.PollKeys contains: F12, UpArrow, DownArrow, LeftArrow, RightArrow, Home, End, Tab, Return
6. Verify ContextDetector._registry exists and Register method is public
7. Verify ModInputRouter passes Escape through (IsPassThroughAction includes Action.Escape)
</verification>

<success_criteria>
- BaseMenuHandler subclass can be created by implementing only DiscoverWidgets, DisplayName, and HelpEntries -- all navigation, speech, search, and input handling come from the base class
- TypeAheadSearch is fully functional in OniAccess namespace with SpeechPipeline integration
- KeyPoller polls all keys needed for menu navigation (arrows, Home, End, Tab, Return, F12)
- ContextDetector can register screen types and will push/pop handlers on screen lifecycle
- Escape passes through CapturesAllInput handlers to reach game screens for closing
- Project builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-menu-navigation/03-01-SUMMARY.md`
</output>
