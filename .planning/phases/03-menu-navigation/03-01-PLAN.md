---
phase: 03-menu-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - OniAccess/Input/ScreenHandler.cs
  - OniAccess/Input/BaseMenuHandler.cs
  - OniAccess/Input/WidgetInfo.cs
  - OniAccess/Input/ISearchable.cs
  - OniAccess/Input/TypeAheadSearch.cs
  - OniAccess/Input/KeyPoller.cs
  - OniAccess/Input/ContextDetector.cs
  - OniAccess/Input/ModInputRouter.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "ScreenHandler provides common screen infrastructure: F12 help, Shift+I tooltip, type-ahead search, screen entry speech, widget lifecycle, and composable default help entries"
    - "BaseMenuHandler extends ScreenHandler with 1D list navigation: arrow wrap-around, Home/End, Enter activation, Left/Right adjustment, Tab stubs"
    - "TypeAheadSearch and ISearchable are ported into OniAccess namespace with dependencies on SpeechPipeline instead of external Speech class"
    - "KeyPoller polls Home, End, Tab, and Return keys alongside existing F12 and arrow keys"
    - "ContextDetector has a registry mechanism that maps screen types to handler factories and pushes/pops handlers on HandlerStack"
    - "WidgetInfo captures label, component reference, widget type, and GameObject for any interactive widget"
    - "ModInputRouter passes Escape through CapturesAllInput handlers so game screens can close themselves"
  artifacts:
    - path: "OniAccess/Input/ScreenHandler.cs"
      provides: "Abstract base for all screen handlers (infrastructure only, no navigation)"
      contains: "abstract class ScreenHandler"
    - path: "OniAccess/Input/BaseMenuHandler.cs"
      provides: "1D list navigation layer extending ScreenHandler"
      contains: "abstract class BaseMenuHandler : ScreenHandler"
    - path: "OniAccess/Input/WidgetInfo.cs"
      provides: "Widget metadata and WidgetType enum"
      contains: "enum WidgetType"
    - path: "OniAccess/Input/ISearchable.cs"
      provides: "Interface for type-ahead search integration"
      contains: "interface ISearchable"
    - path: "OniAccess/Input/TypeAheadSearch.cs"
      provides: "Type-ahead search with word-start matching and same-letter cycling"
      contains: "class TypeAheadSearch"
    - path: "OniAccess/Input/ContextDetector.cs"
      provides: "Screen-to-handler registry with push/pop lifecycle"
      contains: "_registry"
  key_links:
    - from: "OniAccess/Input/ScreenHandler.cs"
      to: "OniAccess/Input/IAccessHandler.cs"
      via: "implements IAccessHandler and ISearchable"
      pattern: "IAccessHandler"
    - from: "OniAccess/Input/BaseMenuHandler.cs"
      to: "OniAccess/Input/ScreenHandler.cs"
      via: "extends ScreenHandler with 1D list navigation"
      pattern: "ScreenHandler"
    - from: "OniAccess/Input/ScreenHandler.cs"
      to: "OniAccess/Input/TypeAheadSearch.cs"
      via: "holds TypeAheadSearch instance for A-Z search"
      pattern: "TypeAheadSearch"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/HandlerStack.cs"
      via: "Push/Pop handlers when screens activate/deactivate"
      pattern: "HandlerStack\\.Push|HandlerStack\\.Pop"
    - from: "OniAccess/Input/TypeAheadSearch.cs"
      to: "OniAccess/Speech/SpeechPipeline.cs"
      via: "SpeakInterrupt for search announcements"
      pattern: "SpeechPipeline\\.SpeakInterrupt"
---

<objective>
Build the generic KScreen accessibility infrastructure that all screen handlers inherit from. This is the reusable foundation for Phases 3, 7, 8, and 12.

Purpose: Provide a two-layer class hierarchy -- ScreenHandler (common infrastructure) and BaseMenuHandler (1D list navigation) -- so that list-based handlers only implement DiscoverWidgets/DisplayName/HelpEntries, and future 2D grid handlers (Phase 8) can share infrastructure without inheriting irrelevant 1D navigation. Port TypeAheadSearch. Extend KeyPoller. Wire ContextDetector registry.

Output: ScreenHandler + BaseMenuHandler class hierarchy, WidgetInfo/WidgetType, ISearchable, TypeAheadSearch, updated KeyPoller, ContextDetector, ModInputRouter, and help LocStrings.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-menu-navigation/03-RESEARCH.md
@OniAccess/Input/IAccessHandler.cs
@OniAccess/Input/HandlerStack.cs
@OniAccess/Input/ContextDetector.cs
@OniAccess/Input/KeyPoller.cs
@OniAccess/Input/HelpHandler.cs
@OniAccess/Input/WorldHandler.cs
@OniAccess/Input/ModInputRouter.cs
@OniAccess/Speech/SpeechPipeline.cs
@OniAccess/Input/HelpEntry.cs
@OniAccess/OniAccessStrings.cs
@TypeAheadSearch.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: WidgetInfo, ISearchable, and TypeAheadSearch port</name>
  <files>
    OniAccess/Input/WidgetInfo.cs
    OniAccess/Input/ISearchable.cs
    OniAccess/Input/TypeAheadSearch.cs
  </files>
  <action>
Create three new files in OniAccess/Input/:

**WidgetInfo.cs** -- Data class and enum for widget metadata:
- `WidgetType` enum: `Button`, `Toggle`, `Slider`, `Dropdown`, `Label`, `TextInput`
- `WidgetInfo` class with properties:
  - `string Label` -- speakable text for the widget
  - `UnityEngine.Component Component` -- the KButton/KToggle/KSlider/etc reference
  - `WidgetType Type` -- what kind of widget this is
  - `UnityEngine.GameObject GameObject` -- the widget's GameObject (for tooltip access)
- Namespace: `OniAccess.Input`

**ISearchable.cs** -- Port from repo-root TypeAheadSearch.cs `ISearchable` interface:
- Keep same 4 members: `SearchItemCount`, `SearchCurrentIndex`, `GetSearchLabel(int)`, `SearchMoveTo(int)`
- Change namespace from `UnityKeyNav` to `OniAccess.Input`
- Keep all XML doc comments

**TypeAheadSearch.cs** -- Port from repo-root TypeAheadSearch.cs:
- Change namespace from `UnityKeyNav` to `OniAccess.Input`
- Replace all `Speech.Say(...)` calls with `OniAccess.Speech.SpeechPipeline.SpeakInterrupt(...)` -- search results should interrupt (per decision: value changes use SpeakInterrupt for rapid adjustment)
- Remove `InputBlocker.BlockCancelOnce = true` line (that's from another project; ONI handles Escape differently)
- Remove `NavigationUtils.WrapIndex` call -- inline the wrap logic: `(_resultCursor + direction % count + count) % count` or use a simple modulo wrap
- Keep all the search logic intact: AddChar, RemoveChar, Clear, Search, NavigateResults, HandleKey, word-start matching, same-letter cycling, buffer timeout
- The `HandleKey` method signature uses `KeyboardManager.KeyModifiers` -- replace this with two bool parameters: `bool ctrlHeld, bool altHeld` since we don't have that type. Update the modifier checks accordingly (replace `modifiers.Control` with `ctrlHeld`, `modifiers.Alt` with `altHeld`)
- Keep `Time.time` for timeout (fully qualify as `UnityEngine.Time.time` per project convention)
- Keep all working-list swap optimization for zero-allocation search

All files must use `System.Action` (not bare `Action`) per project decision.
  </action>
  <verify>
Build the project: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed with no errors.
  </verify>
  <done>
WidgetInfo.cs defines WidgetType enum and WidgetInfo class. ISearchable.cs defines the search interface. TypeAheadSearch.cs is a working port with SpeechPipeline integration and no external dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: ScreenHandler and BaseMenuHandler class hierarchy</name>
  <files>
    OniAccess/Input/ScreenHandler.cs
    OniAccess/Input/BaseMenuHandler.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
Create two new files that form a two-layer class hierarchy. ScreenHandler provides infrastructure every screen handler needs. BaseMenuHandler extends it with 1D list navigation. Phase 8 will add a sibling BaseGridHandler for 2D grids -- that's why the split exists.

---

**ScreenHandler.cs** -- Abstract base for ALL screen handlers:

Namespace: `OniAccess.Input`

**State:**
- `protected readonly List<WidgetInfo> _widgets = new List<WidgetInfo>()`
- `protected int _currentIndex`
- `protected KScreen _screen`
- `protected readonly TypeAheadSearch _search = new TypeAheadSearch()`
- `public KScreen Screen => _screen` (for ContextDetector to match handler to screen)
- Constructor takes `KScreen screen`, stores it in `_screen`

**Abstract members (every subclass MUST implement):**
- `abstract string DisplayName { get; }`
- `abstract IReadOnlyList<HelpEntry> HelpEntries { get; }`
- `abstract void DiscoverWidgets(KScreen screen)` -- populate `_widgets`

**Composable help entry lists (protected static):**

```csharp
protected static readonly List<HelpEntry> CommonHelpEntries = new List<HelpEntry>
{
    new HelpEntry("F12", STRINGS.ONIACCESS.HOTKEYS.CONTEXT_HELP),
    new HelpEntry("Ctrl+Shift+F12", STRINGS.ONIACCESS.HOTKEYS.TOGGLE_MOD),
    new HelpEntry("Shift+I", STRINGS.ONIACCESS.HELP.READ_TOOLTIP),
    new HelpEntry("A-Z", STRINGS.ONIACCESS.HELP.TYPE_SEARCH),
};

protected static readonly List<HelpEntry> ListNavHelpEntries = new List<HelpEntry>
{
    new HelpEntry("Up/Down", STRINGS.ONIACCESS.HELP.NAVIGATE_ITEMS),
    new HelpEntry("Home/End", STRINGS.ONIACCESS.HELP.JUMP_FIRST_LAST),
    new HelpEntry("Enter", STRINGS.ONIACCESS.HELP.SELECT_ITEM),
    new HelpEntry("Left/Right", STRINGS.ONIACCESS.HELP.ADJUST_VALUE),
    new HelpEntry("Shift+Left/Right", STRINGS.ONIACCESS.HELP.ADJUST_VALUE_LARGE),
};
```

Subclasses compose: `CommonHelpEntries.Concat(ListNavHelpEntries).Concat(screenSpecific).ToList().AsReadOnly()`. List-based handlers use both lists. Future 2D grid handlers use CommonHelpEntries + grid-specific entries.

**IAccessHandler implementation:**
- `bool CapturesAllInput => true`
- `virtual void OnActivate()`:
  1. `DiscoverWidgets(_screen)`
  2. `SpeechPipeline.SpeakInterrupt(DisplayName)`
  3. `_currentIndex = 0`
  4. If `_widgets.Count > 0`: `SpeechPipeline.SpeakQueued(GetWidgetSpeechText(_widgets[0]))` (first widget queued behind title, same pattern as HelpHandler)
  5. `_search.Clear()`
- `virtual void OnDeactivate()`: `_currentIndex = 0; _search.Clear()`

**virtual HandleKeyDown(KButtonEvent e):**
- Shift+I (tooltip): check `e.Controller.GetKeyDown(KKeyCode.I)` with Shift held -> `SpeakTooltip()`; `e.Consumed = true`; return true
- A-Z (search): iterate KKeyCode.A through KKeyCode.Z. If pressed, call `_search.HandleKey(keyCode, ctrlHeld, altHeld, this)` where `this` implements ISearchable. If handled, consume event.
- Default: return false

**HandleKeyUp:** return false
**virtual HandleUnboundKey(KeyCode):** F12 -> push HelpHandler with HelpEntries; return true. Default: return false.

**ISearchable implementation** (ScreenHandler implements ISearchable):
- `SearchItemCount => _widgets.Count`
- `SearchCurrentIndex => _currentIndex`
- `GetSearchLabel(int index)` -- bounds-checked, returns `_widgets[index].Label`
- `SearchMoveTo(int index)` -- set `_currentIndex = index`; `SpeakCurrentWidget()`

**Utility methods (protected):**
- `virtual string GetWidgetSpeechText(WidgetInfo widget)` -- default returns `widget.Label`
- `SpeakCurrentWidget()` -- `SpeechPipeline.SpeakInterrupt(GetWidgetSpeechText(_widgets[_currentIndex]))` (bounds-checked)
- `PlayWrapSound()` -- `KFMOD.PlayUISound(GlobalAssets.GetSound("HUD_Click_Close"))` in try/catch
- `SpeakTooltip()` -- read ToolTip from current widget's GameObject, speak via SpeakInterrupt
- `FormatSliderValue(KSlider slider)` -- wholeNumbers: int cast. Otherwise: `GameUtil.GetFormattedPercent` if 0-100 range, else `slider.value.ToString("F1")`

---

**BaseMenuHandler.cs** -- 1D list navigation extending ScreenHandler:

Namespace: `OniAccess.Input`

Inherits `ScreenHandler`. Constructor: `protected BaseMenuHandler(KScreen screen) : base(screen)`

**override HandleUnboundKey(KeyCode keyCode):**
- `DownArrow` -> `NavigateNext()`; return true
- `UpArrow` -> `NavigatePrev()`; return true
- `Home` -> `NavigateFirst()`; return true
- `End` -> `NavigateLast()`; return true
- `Return` -> `ActivateCurrentWidget()`; return true
- `Tab` -> Shift held: `NavigateTabBackward()`, else `NavigateTabForward()`; return true. Check Shift via `UnityEngine.Input.GetKey(KeyCode.LeftShift) || UnityEngine.Input.GetKey(KeyCode.RightShift)`
- `LeftArrow` / `RightArrow` -> `AdjustCurrentWidget(direction, isLargeStep)`. Large step if Shift held. Return true.
- Default: `return base.HandleUnboundKey(keyCode)` (falls through to ScreenHandler for F12)

**Navigation methods (protected):**
- `NavigateNext()`: increment `_currentIndex` with modular wrap. If wrapped to 0, `PlayWrapSound()`. `SpeakCurrentWidget()`.
- `NavigatePrev()`: decrement with wrap. If wrapped to last, `PlayWrapSound()`. `SpeakCurrentWidget()`.
- `NavigateFirst()`: `_currentIndex = 0; SpeakCurrentWidget()`
- `NavigateLast()`: `_currentIndex = _widgets.Count - 1; SpeakCurrentWidget()`
- `virtual void NavigateTabForward()` -- no-op default (subclasses override for tabbed screens)
- `virtual void NavigateTabBackward()` -- no-op default

**Widget interaction (protected virtual):**
- `override string GetWidgetSpeechText(WidgetInfo widget)`: "label, value" for sliders/toggles/dropdowns, "label" for buttons/labels. No type announcement. Toggle: "label, on/off". Slider: "label, formatted_value". Dropdown: "label, current_option".
- `virtual void ActivateCurrentWidget()`: dispatch by WidgetType:
  - Button: `(widget.Component as KButton)?.SignalClick(KKeyCode.Mouse0)` (triggers onClick + plays button sound)
  - Toggle: `(widget.Component as KToggle)?.Click()` then SpeakInterrupt "label, on/off"
  - TextInput: no-op (subclasses handle)
- `virtual void AdjustCurrentWidget(int direction, bool isLargeStep)`: dispatch by WidgetType:
  - Slider: step = wholeNumbers ? (isLargeStep ? 10 : 1) : (isLargeStep ? range*0.1f : range*0.01f). Clamp. SpeakInterrupt "label, formatted_value".
  - Dropdown: call `virtual void CycleDropdown(WidgetInfo widget, int direction)` (no-op default)
- `virtual void CycleDropdown(WidgetInfo widget, int direction)` -- no-op default

---

**OniAccessStrings.cs** -- Add help entry LocStrings:
```
HELP.NAVIGATE_ITEMS = "Navigate items"
HELP.JUMP_FIRST_LAST = "Jump to first or last"
HELP.SELECT_ITEM = "Activate selected item"
HELP.ADJUST_VALUE = "Adjust value"
HELP.ADJUST_VALUE_LARGE = "Adjust value, large step"
HELP.TYPE_SEARCH = "Type-ahead search"
HELP.READ_TOOLTIP = "Read tooltip"
```
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify ScreenHandler implements IAccessHandler and ISearchable. Verify BaseMenuHandler extends ScreenHandler and overrides HandleUnboundKey. Verify composable help lists are static on ScreenHandler.
  </verify>
  <done>
ScreenHandler abstract class provides common infrastructure: F12 help, Shift+I tooltip, A-Z search, screen entry speech, widget lifecycle, and composable help entry lists. BaseMenuHandler extends it with 1D list navigation: arrow wrap, Home/End, Enter activation, Left/Right adjustment, Tab stubs. A concrete list-based handler only needs to implement DiscoverWidgets, DisplayName, and HelpEntries. Future 2D grid handlers (Phase 8) can extend ScreenHandler directly without inheriting irrelevant 1D navigation.
  </done>
</task>

<task type="auto">
  <name>Task 3: KeyPoller extensions, ContextDetector registry, and ModInputRouter Escape pass-through</name>
  <files>
    OniAccess/Input/KeyPoller.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/Input/ModInputRouter.cs
  </files>
  <action>
**KeyPoller.cs** -- Add new keys to the PollKeys array:
- Add `KeyCode.Home`, `KeyCode.End`, `KeyCode.Tab`, `KeyCode.Return` to the `PollKeys` array
- These keys have no ONI Action binding per research, so they must be polled
- Keep existing keys: F12, UpArrow, DownArrow, LeftArrow, RightArrow
- No other changes needed -- the existing dispatch via `HandlerStack.DispatchUnboundKey(key)` already routes to ScreenHandler/BaseMenuHandler.HandleUnboundKey

**ContextDetector.cs** -- Rewrite to add registry mechanism:
- Add `private static readonly Dictionary<System.Type, System.Func<KScreen, IAccessHandler>> _registry = new Dictionary<System.Type, System.Func<KScreen, IAccessHandler>>()`
- Add `public static void Register<TScreen>(System.Func<KScreen, IAccessHandler> factory) where TScreen : KScreen` -- adds `typeof(TScreen)` -> factory mapping
- Add `public static void Register(System.Type screenType, System.Func<KScreen, IAccessHandler> factory)` -- non-generic overload for runtime-resolved types (e.g., `AccessTools.TypeByName`)
- Rewrite `OnScreenActivated(KScreen screen)`:
  1. If screen is null, return
  2. Look up `screen.GetType()` in `_registry`. If not found, log debug and return (unregistered screens are structural UI -- silently ignored)
  3. Create handler via factory: `var handler = factory(screen)`
  4. `HandlerStack.Push(handler)` -- always Push. The deactivate patch pops correctly: when child closes, its handler pops, re-exposing the parent handler.
- Rewrite `OnScreenDeactivating(KScreen screen)`:
  1. If screen is null, return
  2. Get `HandlerStack.ActiveHandler`. If it is a `ScreenHandler` and its `Screen` property == screen, call `HandlerStack.Pop()`. Pops only if the deactivating screen matches the top handler.
  3. Otherwise log debug and do nothing (structural screen deactivating without a handler)
- Rewrite `DetectAndActivate()`:
  1. Check KScreenManager screen stack for any open registered screens. If found, create and push handler.
  2. If none found, push WorldHandler as baseline.

**ModInputRouter.cs** -- Escape pass-through:
- Rename `IsMouseOrZoomAction` to `IsPassThroughAction`
- Add `|| e.IsAction(Action.Escape)` to the check body
- Update both call sites in OnKeyDown and OnKeyUp

This ensures Escape passes through CapturesAllInput handlers to reach the game's KScreen.OnKeyDown, which calls Deactivate(), which fires our Harmony patch, which pops the handler. Handlers that need to intercept Escape (e.g., SaveLoadHandler navigating back from save view) consume it in HandleKeyDown before the pass-through check runs.
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify KeyPoller has 9 poll keys. Verify ContextDetector has Register method and Push/Pop logic using ScreenHandler.Screen. Verify ModInputRouter.IsPassThroughAction includes Action.Escape.
  </verify>
  <done>
KeyPoller polls Home, End, Tab, Return in addition to existing keys. ContextDetector has a type-safe registry with Push on activate and Pop on deactivate (matching via ScreenHandler.Screen). ModInputRouter passes Escape through to game screens. The infrastructure is ready for concrete screen handlers.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj -c Release` -- clean build, no errors
2. Verify ScreenHandler implements IAccessHandler and ISearchable
3. Verify BaseMenuHandler extends ScreenHandler (not IAccessHandler directly)
4. Verify ScreenHandler has CommonHelpEntries and ListNavHelpEntries static lists
5. Verify TypeAheadSearch uses SpeechPipeline (not external Speech class)
6. Verify KeyPoller.PollKeys contains: F12, UpArrow, DownArrow, LeftArrow, RightArrow, Home, End, Tab, Return
7. Verify ContextDetector._registry exists and Register method is public
8. Verify ContextDetector.OnScreenDeactivating checks ScreenHandler.Screen (not BaseMenuHandler.Screen)
9. Verify ModInputRouter passes Escape through (IsPassThroughAction includes Action.Escape)
</verification>

<success_criteria>
- A list-based handler subclass can be created by extending BaseMenuHandler and implementing only DiscoverWidgets, DisplayName, and HelpEntries -- all navigation, speech, search, and input handling come from the two-layer hierarchy
- A future non-list handler (e.g., Phase 8 grid) can extend ScreenHandler directly and get F12, tooltip, search, speech without inheriting 1D navigation
- TypeAheadSearch is fully functional in OniAccess namespace with SpeechPipeline integration
- KeyPoller polls all keys needed for menu navigation (arrows, Home, End, Tab, Return, F12)
- ContextDetector can register screen types and will push/pop handlers on screen lifecycle
- Escape passes through CapturesAllInput handlers to reach game screens for closing
- Project builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-menu-navigation/03-01-SUMMARY.md`
</output>
