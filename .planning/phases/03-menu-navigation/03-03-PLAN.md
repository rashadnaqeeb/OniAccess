---
phase: 03-menu-navigation
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - OniAccess/Input/Handlers/ColonySetupHandler.cs
  - OniAccess/Input/Handlers/WorldGenHandler.cs
  - OniAccess/Input/ContextDetector.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "User can hear game mode names and descriptions and select one (Survival, No Sweat, etc.)"
    - "User can browse asteroid clusters with name, difficulty, and world traits read aloud"
    - "User can Tab between panels (cluster list, world seed, game settings) on the asteroid selection screen"
    - "User can adjust game settings (disease, hunger, morale, stress) with Left/Right to cycle difficulty levels"
    - "User hears periodic progress updates during world generation (25%, 50%, 75%, Done)"
    - "World generation handler automatically activates when WorldGenScreen opens and deactivates when it closes"
  artifacts:
    - path: "OniAccess/Input/Handlers/ColonySetupHandler.cs"
      provides: "Colony setup flow: mode select, asteroid selection, game settings"
      contains: "class ColonySetupHandler"
    - path: "OniAccess/Input/Handlers/WorldGenHandler.cs"
      provides: "World generation progress announcements"
      contains: "class WorldGenHandler"
  key_links:
    - from: "OniAccess/Input/Handlers/ColonySetupHandler.cs"
      to: "OniAccess/Input/BaseMenuHandler.cs"
      via: "inherits BaseMenuHandler for navigation"
      pattern: "BaseMenuHandler"
    - from: "OniAccess/Input/Handlers/WorldGenHandler.cs"
      to: "OniAccess/Input/IAccessHandler.cs"
      via: "implements IAccessHandler directly (not BaseMenuHandler -- no widgets to navigate)"
      pattern: "IAccessHandler"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/Handlers/ColonySetupHandler.cs"
      via: "registry maps colony setup screen types"
      pattern: "ColonyDestinationSelectScreen|ClusterCategorySelectionScreen"
---

<objective>
Implement handlers for the new game flow screens: game mode selection, asteroid/cluster selection with settings tabs, and world generation progress. A blind user can configure and start a new colony.

Purpose: After clicking "New Game" from the main menu, the user enters a multi-screen flow. Each screen needs specific widget discovery and navigation. The WorldGenScreen is unique -- it's not navigable but needs progress announcements.

Output: ColonySetupHandler (reused across mode select and colony destination screens), WorldGenHandler (progress polling), registered in ContextDetector.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-menu-navigation/03-RESEARCH.md
@.planning/phases/03-menu-navigation/03-01-SUMMARY.md
@.planning/phases/03-menu-navigation/03-02-SUMMARY.md
@OniAccess/Input/BaseMenuHandler.cs
@OniAccess/Input/WidgetInfo.cs
@OniAccess/Input/IAccessHandler.cs
@OniAccess/Input/ContextDetector.cs
@OniAccess/Input/Handlers/MainMenuHandler.cs
@OniAccess/Input/Handlers/OptionsMenuHandler.cs
@OniAccess/OniAccessStrings.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: ColonySetupHandler for game mode and asteroid selection</name>
  <files>
    OniAccess/Input/Handlers/ColonySetupHandler.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**ColonySetupHandler.cs** -- Handler for ColonyDestinationSelectScreen and ClusterCategorySelectionScreen:

This handler serves two distinct screens in the new game flow. Determine which screen is active from `_screen.GetType()` and adapt widget discovery accordingly.

**For ClusterCategorySelectionScreen (game mode select):**
- `DisplayName`: "Game mode" (add LocString)
- Widget discovery: Find `MultiToggle[]` buttons for game modes (Survival, No Sweat, Custom). Per research: `MultiToggle` components in the screen hierarchy. For each MultiToggle, find the associated LocText children containing the mode name and description.
- Per decision: "name and short description read together since description is visually present." In GetWidgetSpeechText, concatenate mode name and description: "Survival, full gameplay with all challenges"
- Activating a mode (Enter key): call `MultiToggle.Click()` on the selected toggle. This selects the game mode and may auto-advance to the next screen.

**For ColonyDestinationSelectScreen (asteroid selection + settings):**
- `DisplayName`: "Colony destination" (add LocString)
- This screen has tabbed panels. Per decision: Tab/Shift+Tab between panels.
- Override `NavigateTabForward()` and `NavigateTabBackward()` to cycle between 3 logical panels:
  1. **Cluster list panel**: cluster/asteroid selection. Navigate with Up/Down through available clusters.
  2. **Settings panel**: game settings (NewGameSettingsPanel). Navigate with Up/Down through settings, Left/Right to cycle difficulty levels.
  3. **Seed panel**: world seed input.
- Track current panel via `private int _currentPanel` (0=clusters, 1=settings, 2=seed)
- When Tab is pressed: increment panel, rediscover widgets for that panel, speak panel name, speak first widget
- When Shift+Tab is pressed: decrement panel (with wrap)

**Panel-specific widget discovery:**

Panel 0 (Cluster list):
- Access `clusterCategories` or the list of cluster options via Traverse. Each entry represents a cluster/asteroid.
- Per decision: "Cluster list entries: name, difficulty, AND world traits all read on navigation. Full info upfront."
- For each cluster entry, build a Label WidgetInfo whose Label is the full composite text: "Terra, Standard difficulty, Warm, Frozen Core" (name, difficulty, traits joined)
- Per decision: "Asteroid selection screen" with traits. Get traits from cluster data -- research shows `ColonyDestinationSelectScreen` has `destinationMapPanel` with cluster data. The exact data access needs runtime testing; use Traverse to access the cluster list and each cluster's name/difficulty/traits.
- `ActivateWidget` on a cluster entry: select that cluster (call the selection method or click the corresponding UI element)

Panel 1 (Settings):
- Access `NewGameSettingsPanel` from the screen. Per research: it contains `CustomGameSettingListWidget` entries.
- Each setting has a label and a current value. Add as Dropdown WidgetInfo.
- Per decision: "Each setting on one line: 'Disease, Default'. Left/Right cycles difficulty levels."
- Override `CycleDropdown`: call the setting widget's cycle method (e.g., `CycleQualitySetting(direction)` or the equivalent API)
- GetWidgetSpeechText for Dropdown: "Disease, Default"

Panel 2 (Seed):
- Find the seed input field (KInputTextField or InputField)
- Add as TextInput WidgetInfo
- Per decision: text input fields handled with Enter to activate, type content, Enter to confirm, Escape to cancel (with pre-edit value cached). Implement text input handling: override `ActivateCurrentWidget` for TextInput type to start edit mode, override `HandleKeyDown` to detect when in text edit mode (pass keys through to the input field), detect Enter to confirm and Escape to cancel.

**HelpEntries:**
- Up/Down: navigate items
- Left/Right: cycle setting value / adjust
- Tab/Shift+Tab: switch panel
- Enter: select/activate
- Shift+I: read tooltip
- F12: help
- A-Z: type-ahead search

Add LocStrings: HANDLERS.GAME_MODE, HANDLERS.COLONY_DESTINATION, and panel name strings (STRINGS.ONIACCESS.PANELS.CLUSTERS, STRINGS.ONIACCESS.PANELS.SETTINGS, STRINGS.ONIACCESS.PANELS.SEED).
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed.
  </verify>
  <done>
ColonySetupHandler handles game mode selection (name + description spoken together) and colony destination screen with tabbed panels (cluster list with traits, settings with Left/Right cycling, seed input). Tab/Shift+Tab switches between panels.
  </done>
</task>

<task type="auto">
  <name>Task 2: WorldGenHandler and ContextDetector registration</name>
  <files>
    OniAccess/Input/Handlers/WorldGenHandler.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**WorldGenHandler.cs** -- Special handler for world generation progress (NOT a BaseMenuHandler subclass):
- Implements `IAccessHandler` directly. Per Pitfall 6: WorldGenScreen has no interactive widgets. It's a progress display.
- `DisplayName => STRINGS.ONIACCESS.HANDLERS.WORLD_GEN` ("Generating world")
- `CapturesAllInput => true` -- block all input during generation (game blocks Escape too)
- `HelpEntries`: empty list or minimal ("World is generating, please wait")
- Private state: `float _lastSpokenPercent = -1f`, `float _lastPollTime`, `float _pollInterval = 2f` (seconds between checks)
- `OnActivate()`: speak "Generating world" via SpeakInterrupt. Set `_lastSpokenPercent = 0; _lastPollTime = UnityEngine.Time.time`

**Progress polling mechanism:**
- WorldGenHandler needs a way to periodically check progress. Options:
  1. Use a MonoBehaviour coroutine -- but WorldGenHandler is not a MonoBehaviour
  2. Use KeyPoller's Update to call a method on the active handler -- but that couples KeyPoller to handler internals
  3. Add an `Update()` method to IAccessHandler interface -- too invasive
  4. Best approach: use a `ITickable` interface that KeyPoller checks. Create a small `ITickable` interface with `void Tick()`. In KeyPoller.Update(), check if the active handler implements ITickable and call Tick(). OR simpler: just read the LocText components from WorldGenScreen directly instead of polling private fields.

Simplest approach per research Finding 8: read `percentText.text` and `updateText.text` LocText components from WorldGenScreen hierarchy rather than accessing private fields. This avoids reflection entirely.

Actually, even simpler: add an `ITickable` check to KeyPoller. When mod is enabled and active handler implements `ITickable`, call `((ITickable)handler).Tick()` each frame. WorldGenHandler implements ITickable.

Create `OniAccess/Input/ITickable.cs`:
```csharp
namespace OniAccess.Input
{
    /// <summary>
    /// Optional interface for handlers that need per-frame updates.
    /// KeyPoller checks for this on the active handler and calls Tick() each frame.
    /// Used by WorldGenHandler for progress polling.
    /// </summary>
    public interface ITickable
    {
        void Tick();
    }
}
```

**WorldGenHandler.Tick():**
1. Check `UnityEngine.Time.time - _lastPollTime < _pollInterval`. If too soon, return.
2. Set `_lastPollTime = UnityEngine.Time.time`
3. Find the percent text: search screen children for LocText containing a percent value. Or use `Traverse.Create(_screen).Field("percentText").GetValue<LocText>()?.text`. Parse the percent from the text string.
4. Alternative: find `OfflineWorldGen` component and read its `currentPercent` field via Traverse: `Traverse.Create(_screen).Field("offlineWorldGen").Field("currentPercent").GetValue<float>()`
5. Round to integer percent. If >= lastSpokenPercent + 25, speak: "{rounded} percent" via SpeakInterrupt. Update _lastSpokenPercent. Per discretion: speak at 25% intervals.
6. If percent >= 100 (or 1.0f): speak "World generation complete"
- `HandleKeyDown`, `HandleKeyUp`, `HandleUnboundKey`: return false for everything (no interaction during world gen)
- `OnDeactivate()`: no-op

**KeyPoller.cs** modification:
- In Update(), after the VanillaMode check, add:
  ```
  // Tick handlers that need per-frame updates (e.g., WorldGenHandler progress)
  var active = HandlerStack.ActiveHandler;
  if (active is ITickable tickable)
      tickable.Tick();
  ```
- Place this BEFORE the key polling loop

**ContextDetector.cs** -- Add registrations for colony setup screens:
- `Register` with `AccessTools.TypeByName("ClusterCategorySelectionScreen")` -> `screen => new Handlers.ColonySetupHandler(screen)` (if type exists; may be DLC-only. Check with null: if type is null, skip registration)
- `Register(typeof(ColonyDestinationSelectScreen))` -> `screen => new Handlers.ColonySetupHandler(screen)`
- `Register` with `AccessTools.TypeByName("WorldGenScreen")` -> `screen => new Handlers.WorldGenHandler(screen)`

**OniAccessStrings.cs** -- Add:
```
HANDLERS.WORLD_GEN = "Generating world"
HANDLERS.GAME_MODE = "Game mode"
HANDLERS.COLONY_DESTINATION = "Colony destination"
PANELS.CLUSTERS = "Clusters"
PANELS.SETTINGS = "Settings"
PANELS.SEED = "World seed"
```
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify WorldGenHandler implements IAccessHandler and ITickable. Verify KeyPoller calls Tick on ITickable handlers.
  </verify>
  <done>
WorldGenHandler polls world generation progress and speaks at 25% intervals via ITickable. KeyPoller ticks the active handler each frame. ColonySetupHandler and WorldGenHandler are registered in ContextDetector for their screen types. World generation announces progress without user interaction required.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj -c Release` -- clean build
2. ColonySetupHandler handles both ClusterCategorySelectionScreen and ColonyDestinationSelectScreen
3. ColonySetupHandler has Tab/Shift+Tab panel switching with 3 panels
4. Game mode entries speak name + description together
5. Cluster entries speak name + difficulty + world traits
6. Settings entries speak "label, value" with Left/Right cycling
7. WorldGenHandler implements ITickable and IAccessHandler (NOT BaseMenuHandler)
8. WorldGenHandler speaks progress at 25% intervals
9. KeyPoller calls Tick() on ITickable active handlers
10. All screen types registered in ContextDetector
</verification>

<success_criteria>
- User flow: Main Menu -> New Game -> Game Mode Select -> Asteroid Selection -> Settings Tab -> World Generation is fully navigable via keyboard with speech
- Game mode speaks name + description per decision
- Asteroid selection has Tab-switchable panels with full cluster info readout
- World generation progress is announced periodically without user input
- Project builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-menu-navigation/03-03-SUMMARY.md`
</output>
