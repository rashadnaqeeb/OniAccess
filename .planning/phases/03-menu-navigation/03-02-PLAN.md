---
phase: 03-menu-navigation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - OniAccess/Input/Handlers/MainMenuHandler.cs
  - OniAccess/Input/Handlers/PauseMenuHandler.cs
  - OniAccess/Input/Handlers/OptionsMenuHandler.cs
  - OniAccess/Input/Handlers/ConfirmDialogHandler.cs
  - OniAccess/Input/Handlers/ColonySummaryHandler.cs
  - OniAccess/Input/ContextDetector.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "User can navigate main menu buttons with Up/Down arrows and hear each button label"
    - "User can activate any main menu button with Enter (New Game, Load, Options, etc.)"
    - "User can navigate pause menu and hear each option"
    - "User can navigate options sub-screens (Audio, Graphics, Game) with slider and toggle interaction"
    - "User can navigate confirmation dialogs and activate OK/Cancel with Enter"
    - "User can navigate colony summary screen to browse retired colonies and achievements (MENU-09)"
    - "Type-ahead search works in main menu (e.g., pressing 'o' jumps to Options)"
    - "Wrap-around plays earcon sound when navigating past last/first item"
  artifacts:
    - path: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      provides: "Main menu button navigation"
      contains: "class MainMenuHandler"
    - path: "OniAccess/Input/Handlers/PauseMenuHandler.cs"
      provides: "Pause menu navigation"
      contains: "class PauseMenuHandler"
    - path: "OniAccess/Input/Handlers/OptionsMenuHandler.cs"
      provides: "Options screens with slider/toggle/dropdown interaction"
      contains: "class OptionsMenuHandler"
    - path: "OniAccess/Input/Handlers/ConfirmDialogHandler.cs"
      provides: "Confirmation dialog navigation"
      contains: "class ConfirmDialogHandler"
    - path: "OniAccess/Input/Handlers/ColonySummaryHandler.cs"
      provides: "Colony summary / retired colony info navigation"
      contains: "class ColonySummaryHandler"
  key_links:
    - from: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      to: "OniAccess/Input/BaseMenuHandler.cs"
      via: "inherits BaseMenuHandler"
      pattern: "BaseMenuHandler"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      via: "registry maps MainMenu type to MainMenuHandler"
      pattern: "MainMenu.*MainMenuHandler"
    - from: "OniAccess/Input/Handlers/OptionsMenuHandler.cs"
      to: "OniAccess/Input/BaseMenuHandler.cs"
      via: "inherits BaseMenuHandler; relies on base GetWidgetSpeechText and AdjustCurrentWidget for standard widget types"
      pattern: "BaseMenuHandler"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/Handlers/ColonySummaryHandler.cs"
      via: "registry maps RetiredColonyInfoScreen to ColonySummaryHandler"
      pattern: "RetiredColonyInfoScreen.*ColonySummaryHandler"
---

<objective>
Implement handlers for the main menu, pause menu, options screens, confirmation dialogs, and colony summary screen -- the first concrete screens users encounter when launching the game.

Purpose: These are the entry-point screens. A blind user must be able to navigate the main menu to start a game, adjust options, respond to confirmation dialogs, and browse retired colony summaries. This validates the BaseMenuHandler infrastructure with real screens.

Output: Five handler classes in Input/Handlers/, registered in ContextDetector, with OniAccessStrings for display names.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-menu-navigation/03-RESEARCH.md
@.planning/phases/03-menu-navigation/03-01-SUMMARY.md
@OniAccess/Input/ScreenHandler.cs
@OniAccess/Input/BaseMenuHandler.cs
@OniAccess/Input/WidgetInfo.cs
@OniAccess/Input/IAccessHandler.cs
@OniAccess/Input/ContextDetector.cs
@OniAccess/OniAccessStrings.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MainMenuHandler, PauseMenuHandler, and ConfirmDialogHandler</name>
  <files>
    OniAccess/Input/Handlers/MainMenuHandler.cs
    OniAccess/Input/Handlers/PauseMenuHandler.cs
    OniAccess/Input/Handlers/ConfirmDialogHandler.cs
  </files>
  <action>
Create the `OniAccess/Input/Handlers/` directory.

**MainMenuHandler.cs** -- Handler for the main menu (MainMenu class):
- Inherits `BaseMenuHandler`
- `DisplayName => STRINGS.ONIACCESS.HANDLERS.MAIN_MENU` (add LocString "Main menu")
- Constructor: `MainMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: MainMenu inherits directly from KScreen (NOT KButtonMenu), so cannot use the `buttons` array pattern. Instead:
  1. Get the `buttonParent` Transform field from MainMenu via `HarmonyLib.Traverse.Create(screen).Field("buttonParent").GetValue<UnityEngine.Transform>()`
  2. If null, fall back to walking `screen.transform` children
  3. For each child of buttonParent, look for active GameObjects containing a `KButton` component
  4. For each KButton found, get the label text from the child `LocText` component: `kbutton.GetComponentInChildren<LocText>()?.text`
  5. Skip buttons with null/empty labels or that are not interactable (`!kbutton.isInteractable`)
  6. Also check the `Button_ResumeGame` serialized field (separate from MakeButton buttons): `Traverse.Create(screen).Field("Button_ResumeGame").GetValue<KButton>()`. If non-null and active, add it to widgets (typically first position)
  7. Add each as `WidgetInfo { Label = label, Component = kbutton, Type = WidgetType.Button, GameObject = kbutton.gameObject }`
- `HelpEntries`: Compose `CommonHelpEntries + ListNavHelpEntries` from ScreenHandler. No screen-specific additions needed.

**PauseMenuHandler.cs** -- Handler for the pause menu (PauseScreen class):
- Inherits `BaseMenuHandler`
- `DisplayName => STRINGS.ONIACCESS.HANDLERS.PAUSE_MENU` (add LocString "Pause menu")
- Constructor: `PauseMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: PauseScreen inherits KModalButtonMenu (which inherits KButtonMenu). Use the `buttons` array pattern from research:
  1. `var buttons = Traverse.Create(screen).Field("buttons").GetValue<System.Collections.IList>()`
  2. `var buttonObjects = Traverse.Create(screen).Field("buttonObjects").GetValue<UnityEngine.GameObject[]>()`
  3. Iterate: for each index where buttonObjects[i] is non-null and active, get KButton component, check isInteractable
  4. Get label from buttons[i] -- it's a `KButtonMenu.ButtonInfo` with `.text` property. Access via Traverse: `Traverse.Create(buttons[i]).Property("text").GetValue<string>()`
  5. Add as Button WidgetInfo
- Per Pitfall 3: `RefreshButtons()` destroys cached references. Override `OnActivate()` to always call `DiscoverWidgets` fresh (base class already does this)
- `HelpEntries`: Compose `CommonHelpEntries + ListNavHelpEntries` from ScreenHandler. Same as MainMenu.

**ConfirmDialogHandler.cs** -- Handler for confirmation dialogs (ConfirmDialogScreen):
- Inherits `BaseMenuHandler`
- `DisplayName`: read from the dialog's title text if available, otherwise use `STRINGS.ONIACCESS.HANDLERS.CONFIRM_DIALOG` ("Confirm")
- Constructor: `ConfirmDialogHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: Per decision: confirmation dialogs treated as vertical list. Focus starts on text element (dialog message).
  1. Find the dialog message LocText: look for `popupMessage` or a LocText child containing the dialog text. Use `Traverse.Create(screen).Field("popupMessage")` or search children
  2. Add the message text as a Label WidgetInfo (not clickable, just readable)
  3. Find confirm/cancel buttons: look for `confirmButton` and `cancelButton` fields, or walk children for KButton instances with "Confirm"/"OK"/"Cancel" labels
  4. Add each button as WidgetInfo.Button
- No overrides needed for Label widgets -- ScreenHandler's default GetWidgetSpeechText already returns widget.Label, and BaseMenuHandler's ActivateCurrentWidget has no Label case (already a no-op).
- `HelpEntries`: Compose `CommonHelpEntries + ListNavHelpEntries` from ScreenHandler. No screen-specific additions needed for a simple dialog.

Add LocStrings to OniAccessStrings.cs:
```
HANDLERS.MAIN_MENU = "Main menu"
HANDLERS.PAUSE_MENU = "Pause menu"
HANDLERS.CONFIRM_DIALOG = "Confirm"
```
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed.
  </verify>
  <done>
MainMenuHandler navigates MainMenu buttons via buttonParent traversal. PauseMenuHandler navigates PauseScreen via KButtonMenu.buttons array. ConfirmDialogHandler shows dialog message then OK/Cancel buttons. All three inherit BaseMenuHandler for arrow nav, wrap, Home/End, Enter, search.
  </done>
</task>

<task type="auto">
  <name>Task 2: OptionsMenuHandler and ContextDetector registration</name>
  <files>
    OniAccess/Input/Handlers/OptionsMenuHandler.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**OptionsMenuHandler.cs** -- Handler for options screens (OptionsMenuScreen, AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen):
- Inherits `BaseMenuHandler`
- `DisplayName`: determined from screen type. Override `OnActivate` to check `_screen.GetType().Name` and set a display-friendly name: "Audio options", "Graphics options", "Game options", "Options". Or simpler: get the screen title LocText from the screen hierarchy and use that. Store computed name and return from DisplayName property.
- Constructor: `OptionsMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: Options screens vary but share patterns:
  1. If screen is OptionsMenuScreen (the top-level options menu): it's a KModalButtonMenu. Use the buttons array pattern (same as PauseMenuHandler) to get menu items (Audio, Graphics, Game, Controls, Accounts)
  2. If screen is AudioOptionsScreen: find KSlider components for volume controls (Master, Music, SFX, Ambience, UI). Each slider has a parent with a LocText label. Walk `screen.GetComponentsInChildren<KSlider>()`, for each find sibling/parent LocText for label. Add as Slider WidgetInfo. Also find checkboxes/toggles.
  3. If screen is GraphicsOptionsScreen or GameOptionsScreen: find toggles (KToggle or MultiToggle) and dropdowns. Walk `screen.GetComponentsInChildren<KToggle>()` and find associated labels.
  4. General fallback: walk `screen.GetComponentsInChildren<KButton>(true)` for buttons, `GetComponentsInChildren<KSlider>(true)` for sliders, `GetComponentsInChildren<KToggle>(true)` for toggles. Filter out non-interactable and mouse-only controls (per decision: filter out drag handles, resize handles, etc.)
  5. Mouse-only control filter: skip GameObjects with names containing "drag", "resize", "close" (case-insensitive), or that have no associated LocText label at all
- GetWidgetSpeechText and AdjustCurrentWidget: BaseMenuHandler already handles slider ("label, formatted_value"), toggle ("label, on/off"), and button ("label") speech. No override needed for standard widget types. Only override if a specific options screen has non-standard widgets that need custom speech or adjustment logic.
- `HelpEntries`: Compose `CommonHelpEntries + ListNavHelpEntries` from ScreenHandler. The base lists already cover Up/Down, Left/Right adjust, Enter, Shift+I tooltip, F12, and toggle mod. No screen-specific additions needed.

**ContextDetector.cs** -- Register all handlers:

Add a `public static void RegisterPhase3Handlers()` method (or call registration inline in a static constructor / initialization method). Register:
- `typeof(MainMenu)` -> `screen => new Handlers.MainMenuHandler(screen)`
- `typeof(PauseScreen)` -> `screen => new Handlers.PauseMenuHandler(screen)`
- `typeof(ConfirmDialogScreen)` -> `screen => new Handlers.ConfirmDialogHandler(screen)`
- `typeof(OptionsMenuScreen)` -> `screen => new Handlers.OptionsMenuHandler(screen)`
- For options sub-screens that may not have a direct `typeof` available (AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen): use `AccessTools.TypeByName("AudioOptionsScreen")` etc. and the non-generic Register overload, all mapping to `screen => new Handlers.OptionsMenuHandler(screen)`

Call `RegisterPhase3Handlers()` from `ContextDetector`'s static constructor or from the existing init path.

Note: future plans (03-03, 03-04) will add more registrations for colony setup, duplicant selection, save/load, and worldgen screens.

**OniAccessStrings.cs** -- Add:
```
HANDLERS.OPTIONS = "Options"
HANDLERS.AUDIO_OPTIONS = "Audio options"
HANDLERS.GRAPHICS_OPTIONS = "Graphics options"
HANDLERS.GAME_OPTIONS = "Game options"
```

Note: Help entry LocStrings (NAVIGATE_ITEMS, SELECT_ITEM, ADJUST_VALUE, etc.) are defined in 03-01 with the ScreenHandler composable help lists.
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify ContextDetector has registrations for MainMenu, PauseScreen, ConfirmDialogScreen, OptionsMenuScreen, and options sub-screens.
  </verify>
  <done>
OptionsMenuHandler handles all options sub-screens with slider percentage readout, toggle on/off state, and dropdown cycling. All Phase 3 handlers for basic screens are registered in ContextDetector. LocStrings added for all handler display names and help entries.
  </done>
</task>

<task type="auto">
  <name>Task 3: ColonySummaryHandler for RetiredColonyInfoScreen (MENU-09)</name>
  <files>
    OniAccess/Input/Handlers/ColonySummaryHandler.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**ColonySummaryHandler.cs** -- Handler for RetiredColonyInfoScreen (colony summary accessible from main menu and pause menu):

Inherits `BaseMenuHandler`.

**Screen structure:** RetiredColonyInfoScreen (inherits KModalScreen) has two views:
1. **Explorer view** (`explorerRoot`): a grid of colony buttons showing past/retired colonies, plus an achievement search field
2. **Colony detail view** (`colonyDataRoot`): stats, achievements, duplicants, and buildings for a selected colony

Track current view via `private bool _inColonyDetail = false`.

**DisplayName**: `STRINGS.ONIACCESS.HANDLERS.COLONY_SUMMARY` ("Colony summary")

**DiscoverWidgets(KScreen screen):**

If `_inColonyDetail == false` (explorer view -- colony list):
1. Access `explorerGrid` Transform via `Traverse.Create(screen).Field("explorerGrid").GetValue<UnityEngine.Transform>()`
2. Find colony entry buttons: iterate children of explorerGrid, each colony entry has a KButton component and child LocText elements containing colony name and stats
3. For each colony entry, get the colony name LocText. Build label: colony name. Add as Button WidgetInfo
4. Also add `viewOtherColoniesButton` if active, and `quitToMainMenuButton` if active, as Button widgets
5. Add `closeScreenButton` as a Button widget labeled "Close"

If `_inColonyDetail == true` (colony detail view):
1. Access `colonyName` LocText via Traverse for the colony header name
2. Access `cycleCount` LocText for cycle count
3. Add colony name + cycle count as a Label widget at top
4. Find stat blocks in `statsContainer`: iterate children for stat entries. Each stat block has a label LocText. Add each as Label WidgetInfo
5. Find achievement entries in `achievementsContainer`: each achievement has a name LocText and status. Add as Label widgets with "achievement_name, locked/unlocked" format
6. Add navigation buttons: `viewOtherColoniesButton` ("View other colonies"), `closeScreenButton` ("Close")

**Handling view transitions:**
- When Enter is pressed on a colony in the explorer view: the game shows colony detail. Override `ActivateCurrentWidget` to:
  1. Click the colony entry button (SignalClick)
  2. Set `_inColonyDetail = true`
  3. Rediscover widgets
  4. Speak: colony name then first stat entry

- When Escape or "View other colonies" is pressed in colony detail view: go back to explorer. Override HandleKeyDown for Escape:
  1. If `_inColonyDetail`, set `_inColonyDetail = false`
  2. Click `viewOtherColoniesButton` to return to explorer
  3. Rediscover widgets
  4. Speak: "Colony summary" then first colony entry
  5. Consume the Escape event (don't close the screen from detail view)
  6. Return true
  - If NOT `_inColonyDetail`, let Escape pass through to close the screen normally

**HelpEntries:** Compose `CommonHelpEntries + ListNavHelpEntries` from ScreenHandler. No screen-specific additions needed.

**ContextDetector.cs** -- Add registration:
- `Register(typeof(RetiredColonyInfoScreen))` -> `screen => new Handlers.ColonySummaryHandler(screen)`

**OniAccessStrings.cs** -- Add:
```
HANDLERS.COLONY_SUMMARY = "Colony summary"
```
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify ColonySummaryHandler has two-view navigation (explorer and detail). Verify ContextDetector has registration for RetiredColonyInfoScreen.
  </verify>
  <done>
ColonySummaryHandler navigates RetiredColonyInfoScreen with two views: colony explorer (list of retired colonies) and colony detail (stats, achievements). Registered in ContextDetector. MENU-09 requirement covered.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj -c Release` -- clean build
2. MainMenuHandler.DiscoverWidgets walks buttonParent, not KButtonMenu.buttons
3. PauseMenuHandler.DiscoverWidgets uses KButtonMenu.buttons array
4. ConfirmDialogHandler starts focus on dialog message text, not buttons
5. OptionsMenuHandler handles sliders (KSlider), toggles (KToggle), and buttons
6. ColonySummaryHandler has two-view navigation (explorer list and colony detail)
7. ContextDetector has registrations for: MainMenu, PauseScreen, ConfirmDialogScreen, OptionsMenuScreen, AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen, RetiredColonyInfoScreen
8. OniAccessStrings has all new handler name LocStrings
</verification>

<success_criteria>
- All five handler classes compile and inherit BaseMenuHandler correctly
- ContextDetector registry is populated with screen-to-handler mappings for all basic screens including RetiredColonyInfoScreen
- Widget discovery patterns match the research findings (buttonParent for MainMenu, buttons array for KButtonMenu derivatives, GetComponentsInChildren for options screens)
- Speech output follows locked decisions: label and value only (no type), SpeakInterrupt for screen name, SpeakQueued for first widget
- Project builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-menu-navigation/03-02-SUMMARY.md`
</output>
