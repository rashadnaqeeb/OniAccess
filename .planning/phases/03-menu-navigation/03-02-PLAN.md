---
phase: 03-menu-navigation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - OniAccess/Input/Handlers/MainMenuHandler.cs
  - OniAccess/Input/Handlers/PauseMenuHandler.cs
  - OniAccess/Input/Handlers/OptionsMenuHandler.cs
  - OniAccess/Input/Handlers/ConfirmDialogHandler.cs
  - OniAccess/Input/ContextDetector.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "User can navigate main menu buttons with Up/Down arrows and hear each button label"
    - "User can activate any main menu button with Enter (New Game, Load, Options, etc.)"
    - "User can navigate pause menu and hear each option"
    - "User can navigate options sub-screens (Audio, Graphics, Game) with slider and toggle interaction"
    - "User can navigate confirmation dialogs and activate OK/Cancel with Enter"
    - "Type-ahead search works in main menu (e.g., pressing 'o' jumps to Options)"
    - "Wrap-around plays earcon sound when navigating past last/first item"
  artifacts:
    - path: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      provides: "Main menu button navigation"
      contains: "class MainMenuHandler"
    - path: "OniAccess/Input/Handlers/PauseMenuHandler.cs"
      provides: "Pause menu navigation"
      contains: "class PauseMenuHandler"
    - path: "OniAccess/Input/Handlers/OptionsMenuHandler.cs"
      provides: "Options screens with slider/toggle/dropdown interaction"
      contains: "class OptionsMenuHandler"
    - path: "OniAccess/Input/Handlers/ConfirmDialogHandler.cs"
      provides: "Confirmation dialog navigation"
      contains: "class ConfirmDialogHandler"
  key_links:
    - from: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      to: "OniAccess/Input/BaseMenuHandler.cs"
      via: "inherits BaseMenuHandler"
      pattern: "BaseMenuHandler"
    - from: "OniAccess/Input/ContextDetector.cs"
      to: "OniAccess/Input/Handlers/MainMenuHandler.cs"
      via: "registry maps MainMenu type to MainMenuHandler"
      pattern: "MainMenu.*MainMenuHandler"
    - from: "OniAccess/Input/Handlers/OptionsMenuHandler.cs"
      to: "OniAccess/Input/BaseMenuHandler.cs"
      via: "overrides AdjustCurrentWidget for slider/toggle interaction"
      pattern: "AdjustCurrentWidget|GetWidgetSpeechText"
---

<objective>
Implement handlers for the main menu, pause menu, options screens, and confirmation dialogs -- the first concrete screens users encounter when launching the game.

Purpose: These are the entry-point screens. A blind user must be able to navigate the main menu to start a game, adjust options, and respond to confirmation dialogs. This validates the BaseMenuHandler infrastructure with real screens.

Output: Four handler classes in Input/Handlers/, registered in ContextDetector, with OniAccessStrings for display names.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-menu-navigation/03-RESEARCH.md
@.planning/phases/03-menu-navigation/03-01-SUMMARY.md
@OniAccess/Input/BaseMenuHandler.cs
@OniAccess/Input/WidgetInfo.cs
@OniAccess/Input/IAccessHandler.cs
@OniAccess/Input/ContextDetector.cs
@OniAccess/OniAccessStrings.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: MainMenuHandler, PauseMenuHandler, and ConfirmDialogHandler</name>
  <files>
    OniAccess/Input/Handlers/MainMenuHandler.cs
    OniAccess/Input/Handlers/PauseMenuHandler.cs
    OniAccess/Input/Handlers/ConfirmDialogHandler.cs
  </files>
  <action>
Create the `OniAccess/Input/Handlers/` directory.

**MainMenuHandler.cs** -- Handler for the main menu (MainMenu class):
- Inherits `BaseMenuHandler`
- `DisplayName => STRINGS.ONIACCESS.HANDLERS.MAIN_MENU` (add LocString "Main menu")
- Constructor: `MainMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: MainMenu inherits directly from KScreen (NOT KButtonMenu), so cannot use the `buttons` array pattern. Instead:
  1. Get the `buttonParent` Transform field from MainMenu via `HarmonyLib.Traverse.Create(screen).Field("buttonParent").GetValue<UnityEngine.Transform>()`
  2. If null, fall back to walking `screen.transform` children
  3. For each child of buttonParent, look for active GameObjects containing a `KButton` component
  4. For each KButton found, get the label text from the child `LocText` component: `kbutton.GetComponentInChildren<LocText>()?.text`
  5. Skip buttons with null/empty labels or that are not interactable (`!kbutton.isInteractable`)
  6. Also check the `Button_ResumeGame` serialized field (separate from MakeButton buttons): `Traverse.Create(screen).Field("Button_ResumeGame").GetValue<KButton>()`. If non-null and active, add it to widgets (typically first position)
  7. Add each as `WidgetInfo { Label = label, Component = kbutton, Type = WidgetType.Button, GameObject = kbutton.gameObject }`
- `HelpEntries`: standard menu help -- Up/Down navigate, Enter select, F12 help, Ctrl+Shift+F12 toggle mod, A-Z type-ahead search

**PauseMenuHandler.cs** -- Handler for the pause menu (PauseScreen class):
- Inherits `BaseMenuHandler`
- `DisplayName => STRINGS.ONIACCESS.HANDLERS.PAUSE_MENU` (add LocString "Pause menu")
- Constructor: `PauseMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: PauseScreen inherits KModalButtonMenu (which inherits KButtonMenu). Use the `buttons` array pattern from research:
  1. `var buttons = Traverse.Create(screen).Field("buttons").GetValue<System.Collections.IList>()`
  2. `var buttonObjects = Traverse.Create(screen).Field("buttonObjects").GetValue<UnityEngine.GameObject[]>()`
  3. Iterate: for each index where buttonObjects[i] is non-null and active, get KButton component, check isInteractable
  4. Get label from buttons[i] -- it's a `KButtonMenu.ButtonInfo` with `.text` property. Access via Traverse: `Traverse.Create(buttons[i]).Property("text").GetValue<string>()`
  5. Add as Button WidgetInfo
- Per Pitfall 3: `RefreshButtons()` destroys cached references. Override `OnActivate()` to always call `DiscoverWidgets` fresh (base class already does this)
- `HelpEntries`: same as MainMenu

**ConfirmDialogHandler.cs** -- Handler for confirmation dialogs (ConfirmDialogScreen):
- Inherits `BaseMenuHandler`
- `DisplayName`: read from the dialog's title text if available, otherwise use `STRINGS.ONIACCESS.HANDLERS.CONFIRM_DIALOG` ("Confirm")
- Constructor: `ConfirmDialogHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: Per decision: confirmation dialogs treated as vertical list. Focus starts on text element (dialog message).
  1. Find the dialog message LocText: look for `popupMessage` or a LocText child containing the dialog text. Use `Traverse.Create(screen).Field("popupMessage")` or search children
  2. Add the message text as a Label WidgetInfo (not clickable, just readable)
  3. Find confirm/cancel buttons: look for `confirmButton` and `cancelButton` fields, or walk children for KButton instances with "Confirm"/"OK"/"Cancel" labels
  4. Add each button as WidgetInfo.Button
- Override `GetWidgetSpeechText` for Label type: just return the label text
- Override `ActivateCurrentWidget` for Label type: no-op (can't click text)
- `HelpEntries`: Up/Down navigate, Enter select, F12 help

Add LocStrings to OniAccessStrings.cs:
```
HANDLERS.MAIN_MENU = "Main menu"
HANDLERS.PAUSE_MENU = "Pause menu"
HANDLERS.CONFIRM_DIALOG = "Confirm"
```

Also add help-related strings if needed for the new help entries.
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed.
  </verify>
  <done>
MainMenuHandler navigates MainMenu buttons via buttonParent traversal. PauseMenuHandler navigates PauseScreen via KButtonMenu.buttons array. ConfirmDialogHandler shows dialog message then OK/Cancel buttons. All three inherit BaseMenuHandler for arrow nav, wrap, Home/End, Enter, search.
  </done>
</task>

<task type="auto">
  <name>Task 2: OptionsMenuHandler and ContextDetector registration</name>
  <files>
    OniAccess/Input/Handlers/OptionsMenuHandler.cs
    OniAccess/Input/ContextDetector.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**OptionsMenuHandler.cs** -- Handler for options screens (OptionsMenuScreen, AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen):
- Inherits `BaseMenuHandler`
- `DisplayName`: determined from screen type. Override `OnActivate` to check `_screen.GetType().Name` and set a display-friendly name: "Audio options", "Graphics options", "Game options", "Options". Or simpler: get the screen title LocText from the screen hierarchy and use that. Store computed name and return from DisplayName property.
- Constructor: `OptionsMenuHandler(KScreen screen) : base(screen)`
- `DiscoverWidgets(KScreen screen)`: Options screens vary but share patterns:
  1. If screen is OptionsMenuScreen (the top-level options menu): it's a KModalButtonMenu. Use the buttons array pattern (same as PauseMenuHandler) to get menu items (Audio, Graphics, Game, Controls, Accounts)
  2. If screen is AudioOptionsScreen: find KSlider components for volume controls (Master, Music, SFX, Ambience, UI). Each slider has a parent with a LocText label. Walk `screen.GetComponentsInChildren<KSlider>()`, for each find sibling/parent LocText for label. Add as Slider WidgetInfo. Also find checkboxes/toggles.
  3. If screen is GraphicsOptionsScreen or GameOptionsScreen: find toggles (KToggle or MultiToggle) and dropdowns. Walk `screen.GetComponentsInChildren<KToggle>()` and find associated labels.
  4. General fallback: walk `screen.GetComponentsInChildren<KButton>(true)` for buttons, `GetComponentsInChildren<KSlider>(true)` for sliders, `GetComponentsInChildren<KToggle>(true)` for toggles. Filter out non-interactable and mouse-only controls (per decision: filter out drag handles, resize handles, etc.)
  5. Mouse-only control filter: skip GameObjects with names containing "drag", "resize", "close" (case-insensitive), or that have no associated LocText label at all
- Override `GetWidgetSpeechText(WidgetInfo widget)`:
  - For Slider: get `KSlider` component, return "label, value_percent" where value is formatted. Per decision: "Master Volume, 80 percent"
  - For Toggle: check toggle state. For KToggle: access `isOn` property. Return "label, on" or "label, off". Per decision: "Fullscreen, on"
  - For Button: just label
  - For Dropdown: get current value text. Return "label, value"
- Override `AdjustCurrentWidget(int direction, bool isLargeStep)`:
  - For Slider: base class handles it (uses slider.wholeNumbers step logic)
  - For Dropdown/Toggle: Left/Right cycles. For toggles: Left/Right act as toggle (click). For dropdowns: cycle through options
- `HelpEntries`: Up/Down navigate, Left/Right adjust value, Shift+Left/Right large step, Enter toggle/activate, Shift+I tooltip, F12 help, Ctrl+Shift+F12 toggle mod

**ContextDetector.cs** -- Register all handlers:

Add a `public static void RegisterPhase3Handlers()` method (or call registration inline in a static constructor / initialization method). Register:
- `typeof(MainMenu)` -> `screen => new Handlers.MainMenuHandler(screen)`
- `typeof(PauseScreen)` -> `screen => new Handlers.PauseMenuHandler(screen)`
- `typeof(ConfirmDialogScreen)` -> `screen => new Handlers.ConfirmDialogHandler(screen)`
- `typeof(OptionsMenuScreen)` -> `screen => new Handlers.OptionsMenuHandler(screen)`
- For options sub-screens that may not have a direct `typeof` available (AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen): use `AccessTools.TypeByName("AudioOptionsScreen")` etc. and the non-generic Register overload, all mapping to `screen => new Handlers.OptionsMenuHandler(screen)`

Call `RegisterPhase3Handlers()` from `ContextDetector`'s static constructor or from the existing init path.

Note: future plans (03-03, 03-04) will add more registrations for colony setup, duplicant selection, save/load, and worldgen screens.

**OniAccessStrings.cs** -- Add:
```
HANDLERS.OPTIONS = "Options"
HANDLERS.AUDIO_OPTIONS = "Audio options"
HANDLERS.GRAPHICS_OPTIONS = "Graphics options"
HANDLERS.GAME_OPTIONS = "Game options"
```

Add help entry strings:
```
HELP.NAVIGATE_ITEMS = "Navigate items"
HELP.SELECT_ITEM = "Activate selected item"
HELP.ADJUST_VALUE = "Adjust value"
HELP.ADJUST_VALUE_LARGE = "Adjust value (large step)"
HELP.TYPE_SEARCH = "Type-ahead search"
HELP.READ_TOOLTIP = "Read tooltip"
```
  </action>
  <verify>
Build: `dotnet build OniAccess/OniAccess.csproj -c Release` must succeed. Verify ContextDetector has registrations for MainMenu, PauseScreen, ConfirmDialogScreen, OptionsMenuScreen, and options sub-screens.
  </verify>
  <done>
OptionsMenuHandler handles all options sub-screens with slider percentage readout, toggle on/off state, and dropdown cycling. All Phase 3 handlers for basic screens are registered in ContextDetector. LocStrings added for all handler display names and help entries.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build OniAccess/OniAccess.csproj -c Release` -- clean build
2. MainMenuHandler.DiscoverWidgets walks buttonParent, not KButtonMenu.buttons
3. PauseMenuHandler.DiscoverWidgets uses KButtonMenu.buttons array
4. ConfirmDialogHandler starts focus on dialog message text, not buttons
5. OptionsMenuHandler handles sliders (KSlider), toggles (KToggle), and buttons
6. ContextDetector has registrations for: MainMenu, PauseScreen, ConfirmDialogScreen, OptionsMenuScreen, AudioOptionsScreen, GraphicsOptionsScreen, GameOptionsScreen
7. OniAccessStrings has all new handler name LocStrings
</verification>

<success_criteria>
- All four handler classes compile and inherit BaseMenuHandler correctly
- ContextDetector registry is populated with screen-to-handler mappings for all basic screens
- Widget discovery patterns match the research findings (buttonParent for MainMenu, buttons array for KButtonMenu derivatives, GetComponentsInChildren for options screens)
- Speech output follows locked decisions: label and value only (no type), SpeakInterrupt for screen name, SpeakQueued for first widget
- Project builds clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-menu-navigation/03-02-SUMMARY.md`
</output>
