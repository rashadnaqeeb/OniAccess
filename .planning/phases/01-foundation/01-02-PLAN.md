---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - OniAccess/Speech/TextFilter.cs
  - OniAccess/Speech/SpeechPipeline.cs
  - OniAccess/Speech/Announcement.cs
  - OniAccess/Speech/AlertHistory.cs
  - OniAccess/Mod.cs
autonomous: true

must_haves:
  truths:
    - "Speech output contains no raw rich text tags or sprite codes -- all output is clean readable text"
    - "Meaningful sprite tags are converted to words (warning icon -> 'warning:'), decorative tags silently stripped"
    - "Navigation speech interrupts previous speech for responsiveness"
    - "Alert speech queues and is never dropped"
    - "Duplicate simultaneous alerts combine with count ('Broken Wall x2')"
    - "Alert history buffer captures notifications for future Phase 6 navigation"
  artifacts:
    - path: "OniAccess/Speech/TextFilter.cs"
      provides: "Rich text filtering pipeline with regex-based tag stripping and sprite conversion"
      contains: "FilterForSpeech"
    - path: "OniAccess/Speech/Announcement.cs"
      provides: "Value type for speech announcements with priority, interrupt, and category"
      contains: "struct Announcement"
    - path: "OniAccess/Speech/SpeechPipeline.cs"
      provides: "Central speech dispatch with interrupt and queue semantics"
      contains: "SpeakInterrupt"
    - path: "OniAccess/Speech/AlertHistory.cs"
      provides: "Ring buffer for alert history with dedup"
      contains: "class AlertHistory"
  key_links:
    - from: "OniAccess/Speech/SpeechPipeline.cs"
      to: "OniAccess/Speech/TextFilter.cs"
      via: "All text passes through TextFilter.FilterForSpeech before reaching SpeechEngine"
      pattern: "TextFilter\\.FilterForSpeech"
    - from: "OniAccess/Speech/SpeechPipeline.cs"
      to: "OniAccess/Speech/SpeechEngine.cs"
      via: "Pipeline calls SpeechEngine.Say() after filtering"
      pattern: "SpeechEngine\\.Say"
    - from: "OniAccess/Speech/SpeechPipeline.cs"
      to: "OniAccess/Speech/AlertHistory.cs"
      via: "Queued announcements recorded in alert history buffer"
      pattern: "AlertHistory\\.Record"
---

<objective>
Build the speech pipeline with text filtering, interrupt/queue semantics, and alert history buffer.

Purpose: All speech output must flow through a central pipeline that strips rich text, manages interrupt vs queue behavior, deduplicates alerts, and captures history. This is the architectural pattern every future phase depends on -- no caller should ever touch SpeechEngine directly.
Output: TextFilter, Announcement, SpeechPipeline, and AlertHistory classes with TDD-verified text filtering.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@Speech.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TextFilter with TDD -- rich text stripping and sprite conversion</name>
  <files>
    OniAccess/Speech/TextFilter.cs
    OniAccess/Testing/TextFilterTests.cs
  </files>
  <action>
**This task uses TDD: write tests first, then implement.**

Create `OniAccess/Testing/TextFilterTests.cs` as an in-game test class (not NUnit -- ONI mods run inside Unity/Mono where external test frameworks are impractical). Use a simple static test runner pattern:

```csharp
namespace OniAccess.Testing
{
    public static class TextFilterTests
    {
        public static List<(string name, bool passed, string detail)> RunAll() { ... }
    }
}
```

**Test cases to write FIRST (RED phase):**

1. `StripsBoldTags`: `"<b>Warning</b>"` -> `"Warning"`
2. `StripsColorTags`: `"<color=#FF0000>Hot</color>"` -> `"Hot"`
3. `StripsNestedTags`: `"<b><color=red>Alert</color></b>"` -> `"Alert"`
4. `ConvertsSpriteToText`: `"<sprite name=warning>Pipe broken"` -> `"warning: Pipe broken"` (after registering "warning" sprite)
5. `StripsUnregisteredSprite`: `"<sprite name=decorative_icon>text"` -> `"text"` (unregistered = decorative, strip silently)
6. `StripsTmpBracketSprites`: `"[icon_name] some text"` -> `"some text"`
7. `HandlesLinkTags`: `"<link=\"LINK_ID\">Click here</link>"` -> `"Click here"` (extracts display text)
8. `NormalizesWhitespace`: `"word1   word2\n\nword3"` -> `"word1 word2 word3"`
9. `HandlesEmptyAndNull`: `null` -> `""`, `""` -> `""`
10. `PreservesPlainText`: `"Copper Ore, 200 kg, 25Â°C"` -> unchanged
11. `StripsHotkeyPlaceholders`: `"Build a Ladder {Hotkey}"` -> `"Build a Ladder"`
12. `StripsSizeStyle`: `"<size=10><style=\"KKeyword\">text</style></size>"` -> `"text"`

**Then implement `TextFilter.cs` (GREEN phase):**

Namespace: `OniAccess.Speech`

Move the regex patterns from the old Speech.cs and expand:
- `RichTextTagsRegex` = `new Regex("<[^>]+>", RegexOptions.Compiled)` -- catch-all for remaining tags
- `SpriteTagRegex` = `new Regex(@"<sprite\s+name=""?([^"">]+)""?\s*/?>", RegexOptions.Compiled | RegexOptions.IgnoreCase)` -- improved to handle quoted and self-closing variants
- `TmpSpriteTagRegex` = `new Regex(@"\[[^\]]+\]\s*", RegexOptions.Compiled)` -- TextMeshPro shorthand
- `LinkTagRegex` = `new Regex(@"<link=""[^""]*"">(.*?)</link>", RegexOptions.Compiled)` -- extract display text
- `HotkeyPlaceholderRegex` = `new Regex(@"\s*\{Hotkey\}.*", RegexOptions.Compiled)` -- strip from {Hotkey} onward
- `WhitespaceRegex` = `new Regex(@"\s+", RegexOptions.Compiled)` -- normalize

Sprite text map: `private static readonly Dictionary<string, string> _spriteTextMap`

Public API:
- `static void RegisterSprite(string spriteName, string spokenText)` -- for meaningful sprites
- `static string FilterForSpeech(string text)` -- the main pipeline method

Filter order (critical -- per research):
1. Convert known sprite tags to spoken text (before stripping tags)
2. Extract link display text (before stripping tags)
3. Strip hotkey placeholders
4. Strip all remaining rich text tags
5. Strip TMP bracket sprites
6. Clean up empty brackets/parens
7. Normalize whitespace
8. Trim

Register default ONI sprites during initialization:
- `"warning"` -> `"warning:"`
- `"logic_signal_green"` -> `"green signal"`
- `"logic_signal_red"` -> `"red signal"`
- More can be added incrementally (log unrecognized sprites per research recommendation)

Add `Log.Warn` for unrecognized sprite tags so they can be cataloged over time.
  </action>
  <verify>
- `TextFilterTests.RunAll()` returns all tests passing
- Text with rich text tags produces clean output
- Registered sprites convert to spoken text, unregistered sprites are stripped silently (but logged)
- Link tags extract display text
- Hotkey placeholders are stripped
- Plain text passes through unchanged
  </verify>
  <done>
TextFilter strips all rich text, converts meaningful sprites to words, extracts link text, strips hotkey placeholders, and normalizes whitespace. All 12 test cases pass. Unrecognized sprites logged for incremental cataloging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SpeechPipeline, Announcement, and AlertHistory</name>
  <files>
    OniAccess/Speech/Announcement.cs
    OniAccess/Speech/SpeechPipeline.cs
    OniAccess/Speech/AlertHistory.cs
    OniAccess/Mod.cs
  </files>
  <action>
**Announcement.cs** (namespace `OniAccess.Speech`):

```csharp
public enum SpeechPriority { Low, Normal, High, Critical }

public readonly struct Announcement
{
    public string Text { get; }
    public SpeechPriority Priority { get; }
    public bool Interrupt { get; }
    public string Category { get; }  // For dedup (e.g., "navigation", "alert.broken_pipe")

    public Announcement(string text, SpeechPriority priority, bool interrupt, string category = null)
    {
        Text = text;
        Priority = priority;
        Interrupt = interrupt;
        Category = category;
    }
}
```

**SpeechPipeline.cs** (namespace `OniAccess.Speech`):

Static class -- central dispatch point for ALL speech output in the mod.

Public API:
- `SpeakInterrupt(string text, string category = null)` -- interrupt mode for navigation. Stops current speech, speaks immediately. Per locked decision: "Navigation speech interrupts previous speech for responsiveness."
- `SpeakQueued(string text, string category = null, SpeechPriority priority = SpeechPriority.Normal)` -- queue mode for alerts. Per locked decision: "Alert/notification speech: queues, plays in order, never dropped."
- `Silence()` -- stop all speech and clear queue
- `IsActive { get; }` -- returns false when mod is toggled off (checked by VanillaMode in Plan 03)

Internal implementation:
1. ALL text passes through `TextFilter.FilterForSpeech()` before reaching SpeechEngine
2. **Interrupt path:** Call `SpeechEngine.Say(filtered, interrupt: true)` immediately. If same category within same frame (`Time.frameCount`), skip the previous (category dedup for rapid navigation).
3. **Queue path:** Add to `Queue<Announcement>`. Process one per frame in a coroutine or Update-like dispatch. For dedup: if same category announcement already in queue, replace with latest and increment a counter, then append count to text ("Broken Wall x2") per locked decision.
4. Track `_isActive` flag -- when false, all methods return immediately without speaking. Set by VanillaMode (Plan 03).

Add a static `_enabled` field (default true) with `internal static void SetEnabled(bool enabled)` that VanillaMode will call.

**Queue processing detail:**
- Use `SpeechEngine.Say(text, interrupt: false)` for queued items -- Tolk will naturally queue these
- Process queue immediately (drain all pending on each call) rather than one-per-frame, since Tolk's own queue handles pacing
- Dedup logic: when adding to queue, scan existing queue entries for same Category. If found, update text and increment count suffix

**AlertHistory.cs** (namespace `OniAccess.Speech`):

Ring buffer for alert history. Per locked decision: "Create a history buffer for alerts... Full implementation Phase 6; Phase 1 establishes buffer infrastructure."

```csharp
public class AlertEntry
{
    public string Text { get; set; }
    public string Category { get; set; }
    public float GameTime { get; set; }
    public int Cell { get; set; }       // Grid cell for jump-to-location (Phase 6)
    public int Count { get; set; }      // Dedup count
    public float Timestamp { get; set; } // Time.time for dedup window
}
```

Static class `AlertHistory`:
- Fixed-size ring buffer: `AlertEntry[100]`
- `Record(string text, string category, int cell = -1)` -- add entry, dedup same text within 1 second window (per research recommendation)
- `GetRecent(int count)` -- return most recent N entries (for Phase 6 navigation)
- `Clear()` -- reset buffer
- Internal dedup: if most recent entry has same text and was recorded within 1.0 seconds, increment Count instead of creating new entry

**SpeechPipeline -> AlertHistory wiring:**
- In `SpeakQueued()`, after dispatching to SpeechEngine, also call `AlertHistory.Record(text, category)`
- Interrupt speech does NOT go to alert history (navigation is ephemeral)

**Update Mod.cs:**
- In `OnLoad`, after SpeechEngine.Initialize(), change the startup speech to use `SpeechPipeline.SpeakInterrupt()` instead of calling `SpeechEngine.Say()` directly
- This establishes the pattern: nobody calls SpeechEngine.Say directly except SpeechPipeline
  </action>
  <verify>
- Announcement struct compiles with all 4 properties
- SpeechPipeline.SpeakInterrupt routes through TextFilter then SpeechEngine with interrupt=true
- SpeechPipeline.SpeakQueued routes through TextFilter then SpeechEngine with interrupt=false, and records to AlertHistory
- AlertHistory ring buffer stores entries, deduplicates within 1-second window
- AlertHistory.GetRecent returns entries in reverse chronological order
- Mod.cs startup uses SpeechPipeline, not SpeechEngine directly
  </verify>
  <done>
SpeechPipeline is the single dispatch point for all speech. Interrupt mode is responsive (navigation), queue mode preserves all alerts. TextFilter cleans all text before speech. AlertHistory captures queued alerts in a ring buffer with dedup for Phase 6 navigation. Mod.cs startup speaks through the pipeline.
  </done>
</task>

</tasks>

<verification>
1. TextFilter strips `<b>`, `<color>`, `<link>`, `<sprite>`, `[icon]`, `{Hotkey}` tags and produces clean readable text
2. Registered sprites convert to meaningful words, unregistered sprites strip silently
3. SpeechPipeline.SpeakInterrupt stops current speech and speaks immediately
4. SpeechPipeline.SpeakQueued never drops alerts, deduplicates with count suffix
5. AlertHistory captures queued speech in ring buffer with 1-second dedup window
6. All speech flows: Caller -> SpeechPipeline -> TextFilter -> SpeechEngine -> Tolk
7. No code anywhere calls SpeechEngine.Say directly (except SpeechPipeline)
8. TextFilterTests.RunAll() passes all 12 test cases
</verification>

<success_criteria>
- TextFilter handles all rich text tag types found in ONI (bold, color, link, sprite, TMP brackets, hotkey placeholders)
- SpeechPipeline enforces interrupt/queue semantics per locked decisions
- AlertHistory ring buffer stores 100 entries with dedup for future Phase 6 navigation
- TDD tests verify filtering behavior
- Pipeline pattern established: no direct SpeechEngine access from game code
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
