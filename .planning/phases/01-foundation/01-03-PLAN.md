---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - OniAccess/Toggle/VanillaMode.cs
  - OniAccess/Input/AccessContext.cs
  - OniAccess/Input/HotkeyRegistry.cs
  - OniAccess/Input/InputInterceptor.cs
  - OniAccess/Testing/SpeechCapture.cs
  - OniAccess/Patches/InputPatches.cs
  - OniAccess/Mod.cs
  - OniAccess/OniAccessStrings.cs
autonomous: true

must_haves:
  truths:
    - "User can toggle the mod off with Ctrl+Shift+F12 and game returns to normal behavior with no errors"
    - "Toggle off speaks 'Oni-Access off' then silences all mod speech; only toggle hotkey remains active"
    - "Toggle on speaks 'Oni-Access on' with no state readout"
    - "Context help hotkey (F12) lists available commands for current game state"
    - "Speech capture test framework can record and assert against speech output"
    - "Hotkey registry supports context-sensitive bindings where same key does different things in different contexts"
  artifacts:
    - path: "OniAccess/Toggle/VanillaMode.cs"
      provides: "Mod on/off toggle with clean state management"
      contains: "class VanillaMode"
    - path: "OniAccess/Input/HotkeyRegistry.cs"
      provides: "Context-sensitive hotkey registration with help text generation"
      contains: "TryHandle"
    - path: "OniAccess/Input/InputInterceptor.cs"
      provides: "Top-level input handler that routes to HotkeyRegistry"
      contains: "class InputInterceptor"
    - path: "OniAccess/Input/AccessContext.cs"
      provides: "Game context enum for context-sensitive hotkeys"
      contains: "enum AccessContext"
    - path: "OniAccess/Testing/SpeechCapture.cs"
      provides: "Speech capture buffer for test assertions"
      contains: "class SpeechCapture"
    - path: "OniAccess/Patches/InputPatches.cs"
      provides: "Harmony patch wiring input events to InputInterceptor"
      contains: "HarmonyPatch"
  key_links:
    - from: "OniAccess/Toggle/VanillaMode.cs"
      to: "OniAccess/Speech/SpeechPipeline.cs"
      via: "Toggle calls SpeechPipeline.SetEnabled and SpeakInterrupt for confirmation"
      pattern: "SpeechPipeline\\.SetEnabled"
    - from: "OniAccess/Patches/InputPatches.cs"
      to: "OniAccess/Input/InputInterceptor.cs"
      via: "Harmony postfix calls InputInterceptor.HandleKeyDown"
      pattern: "InputInterceptor\\.HandleKeyDown"
    - from: "OniAccess/Input/InputInterceptor.cs"
      to: "OniAccess/Input/HotkeyRegistry.cs"
      via: "InputInterceptor routes events to HotkeyRegistry.TryHandle"
      pattern: "HotkeyRegistry\\.TryHandle"
    - from: "OniAccess/Testing/SpeechCapture.cs"
      to: "OniAccess/Speech/SpeechEngine.cs"
      via: "SpeechCapture hooks into SpeechEngine.OnSpeechOutput callback"
      pattern: "SpeechEngine\\.OnSpeechOutput"
---

<objective>
Implement vanilla mode toggle, context-sensitive hotkey system, input interception, and speech capture testing framework.

Purpose: Complete the Phase 1 foundation by adding the ability to toggle the mod off cleanly, a hotkey system that future phases will register commands into, Harmony-based input interception, and a test capture framework for verifying speech output. These are the last architectural patterns needed before feature work begins.
Output: Working toggle hotkey (Ctrl+Shift+F12), context help hotkey (F12), input routing via Harmony patches, and speech capture for testing.
</objective>

<execution_context>
@C:/Users/rasha/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/rasha/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VanillaMode toggle and context-sensitive hotkey system</name>
  <files>
    OniAccess/Toggle/VanillaMode.cs
    OniAccess/Input/AccessContext.cs
    OniAccess/Input/HotkeyRegistry.cs
    OniAccess/OniAccessStrings.cs
  </files>
  <action>
**AccessContext.cs** (namespace `OniAccess.Input`):

```csharp
public enum AccessContext
{
    Always,       // Active even when mod is off (toggle hotkey only)
    Global,       // Active whenever mod is on, regardless of game state
    WorldView,    // Main gameplay grid view
    MenuOpen,     // Any KScreen/overlay is active
    BuildMode,    // Build tool selected
    // Future phases will add more contexts as needed
}
```

**HotkeyRegistry.cs** (namespace `OniAccess.Input`):

Public class with context-sensitive hotkey registration and help text generation.

```csharp
public class HotkeyBinding
{
    public KKeyCode Key { get; }
    public Modifier Modifiers { get; }     // Use ONI's Modifier enum (None, Ctrl, Shift, Alt, CapsLock, combinations)
    public AccessContext Context { get; }
    public string Description { get; }     // LocString for help text
    public Action Handler { get; }         // Simple action (no event param for now -- consume is handled by interceptor)
    public string OriginalFunction { get; } // Per META-05: document what this key originally did, or null if unbound
}
```

Static class `HotkeyRegistry`:
- `Register(HotkeyBinding binding)` -- add binding to internal list
- `Unregister(KKeyCode key, Modifier modifiers, AccessContext context)` -- remove binding
- `TryHandle(KKeyCode key, Modifier activeModifiers, AccessContext currentContext) -> bool` -- find matching binding, call handler, return true if handled. Match logic: find binding where Key matches, Modifiers match, and Context is either `Always` or matches `currentContext`. If `VanillaMode.IsEnabled` is false, only `Always` context bindings fire.
- `GetHelpText(AccessContext context) -> string` -- generate help listing for all bindings active in this context. Format: one binding per line, "Key: Description". Include `Always` and `Global` bindings plus context-specific ones.
- Frame dedup: track `Time.frameCount` per binding to prevent multiple fires per frame (per pitfall #3 from research)

**VanillaMode.cs** (namespace `OniAccess.Toggle`):

Static class for mod on/off toggle.

```csharp
public static class VanillaMode
{
    public static bool IsEnabled { get; private set; } = true;  // Mod starts ON

    public static void Toggle()
    {
        IsEnabled = !IsEnabled;
        SpeechPipeline.SetEnabled(IsEnabled);

        if (IsEnabled)
        {
            SpeechPipeline.SpeakInterrupt(STRINGS.ONIACCESS.SPEECH.MOD_ON);
        }
        else
        {
            // Speak "off" message BEFORE disabling pipeline
            // Must temporarily re-enable to speak the off message
            SpeechPipeline.SetEnabled(true);
            SpeechPipeline.SpeakInterrupt(STRINGS.ONIACCESS.SPEECH.MOD_OFF);
            SpeechPipeline.SetEnabled(false);
        }
    }
}
```

Per locked decisions:
- Toggle off: "Oni-Access off" -- speech stops, only toggle hotkey remains active
- Toggle on: "Oni-Access on" -- brief confirmation, no state readout
- Only the toggle hotkey remains active when mod is off (AccessContext.Always)
- No separate mute function

**Register Phase 1 hotkeys in Mod.cs init (or a dedicated RegisterHotkeys method):**

1. Toggle: `Ctrl+Shift+F12`, Context: `Always`, Description: `STRINGS.ONIACCESS.HOTKEYS.TOGGLE_MOD`, Handler: `VanillaMode.Toggle`, OriginalFunction: null (F12 is not used by ONI, Ctrl+Shift+F12 even less)
2. Context Help: `F12`, Context: `Global`, Description: `STRINGS.ONIACCESS.HOTKEYS.CONTEXT_HELP`, Handler: speak help text for current context, OriginalFunction: null (F12 not bound in ONI)

**Update OniAccessStrings.cs** to add any new string constants needed (help text headers, etc.):
- `SPEECH.HELP_HEADER` = `"Available commands:"`
- `SPEECH.NO_COMMANDS` = `"No commands available in this context"`

Per locked decision on help: "Context-aware help command: a hotkey lists available commands for current game state"
  </action>
  <verify>
- AccessContext enum compiles with all 5 values
- HotkeyRegistry.Register adds bindings and TryHandle matches by key+modifier+context
- HotkeyRegistry only fires Always-context bindings when VanillaMode.IsEnabled is false
- VanillaMode.Toggle flips state and speaks confirmation via SpeechPipeline
- GetHelpText generates correct listing for a given context
- Frame dedup prevents multiple fires per frame
  </verify>
  <done>
VanillaMode toggles mod on/off with speech confirmation. HotkeyRegistry supports context-sensitive bindings with help text generation. Toggle (Ctrl+Shift+F12) registered as Always context, help (F12) as Global context. Only toggle works when mod is off.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create InputInterceptor, Harmony patches, and SpeechCapture</name>
  <files>
    OniAccess/Input/InputInterceptor.cs
    OniAccess/Patches/InputPatches.cs
    OniAccess/Testing/SpeechCapture.cs
    OniAccess/Mod.cs
  </files>
  <action>
**InputInterceptor.cs** (namespace `OniAccess.Input`):

Static class that bridges ONI's input system to the HotkeyRegistry.

```csharp
public static class InputInterceptor
{
    /// <summary>
    /// Called by Harmony patches when a key event is received.
    /// Determines the current AccessContext and routes to HotkeyRegistry.
    /// </summary>
    public static bool HandleKeyDown(KButtonEvent e)
    {
        if (e.Consumed) return false;

        AccessContext context = DetermineContext();
        // Extract key and modifiers from KButtonEvent
        // KButtonEvent doesn't directly expose the key -- it uses Action-based matching
        // Instead, we need to check against our registered bindings

        // For each registered binding, check if e.TryConsume(binding.Action) succeeds
        // BUT our bindings use raw KKeyCode, not Action enum values

        // Alternative approach: Use KInputController.IsActive to check raw key state
        // This requires understanding ONI's input routing more deeply

        // PRACTICAL APPROACH for Phase 1:
        // Register our hotkeys as custom Action values using GameInputMapping
        // OR check raw key state via Input.GetKeyDown in a Harmony postfix on a frame update

        // RECOMMENDED: Patch PlayerController.OnKeyDown or KInputHandler.HandleKeyDown
        // Use reflection or the KButtonEvent's internal data to extract the key code

        return HotkeyRegistry.TryHandle(keyCode, modifiers, context);
    }

    private static AccessContext DetermineContext()
    {
        // Phase 1 context detection (minimal -- expanded in later phases):
        // - If any KScreen is active (ManagementMenu.Instance.IsScreenOpen() or similar) -> MenuOpen
        // - If BuildTool is active -> BuildMode
        // - Otherwise -> WorldView
        // For Phase 1, since we only have toggle (Always) and help (Global), a simple approach works

        // Check if game is fully loaded first
        if (Game.Instance == null) return AccessContext.Global;

        // Future phases will make this more sophisticated
        return AccessContext.WorldView;
    }
}
```

**IMPORTANT architectural decision (Claude's discretion per CONTEXT.md):**

ONI's input system uses `Action` enum values, not raw key codes, for event matching. The cleanest approach for the mod's hotkey system:

1. Create a `KInputHandler` component attached to a persistent GameObject
2. This handler has high priority in the input handler stack
3. In its `OnKeyDown(KButtonEvent e)`, iterate registered hotkeys and use Unity's `Input.GetKey` to check modifier state, combined with checking if the event matches our key
4. For the toggle (Ctrl+Shift+F12) and help (F12): use `e.TryConsume(Action)` if we can register custom Actions, OR use a Harmony Prefix on `KInputHandler.HandleKeyDown` to intercept before the game's handlers

**Simplest viable approach for Phase 1:**
- Create a MonoBehaviour `InputInterceptor` that attaches to a persistent GameObject
- In `Update()`, check `Input.GetKeyDown(KeyCode.F12)` with modifier checks for our hotkeys
- This avoids the complexity of hooking into ONI's KInputHandler priority system
- Future phases can migrate to proper KInputHandler integration when we need context-sensitive key handling that interacts with ONI's own input routing

Implement this simpler approach:
- `InputInterceptor : MonoBehaviour` with `Update()` method
- Check `Input.GetKeyDown(KeyCode.F12)`:
  - If Ctrl+Shift held: toggle
  - If no modifiers and mod is on: help
- Call `HotkeyRegistry.TryHandle()` with appropriate key/modifier/context
- In Mod.cs OnLoad, create a persistent GameObject: `var go = new GameObject("OniAccess_Input"); UnityEngine.Object.DontDestroyOnLoad(go); go.AddComponent<InputInterceptor>();`

**InputPatches.cs** (namespace `OniAccess.Patches`):

For Phase 1 with the MonoBehaviour approach, we don't need input Harmony patches. However, create the file as a placeholder with a lifecycle patch:

```csharp
[HarmonyPatch(typeof(Game), "OnDestroy")]
internal static class Game_OnDestroy_Patch
{
    private static void Postfix()
    {
        SpeechEngine.Shutdown();
    }
}
```

This ensures Tolk is properly unloaded when the game shuts down.

**SpeechCapture.cs** (namespace `OniAccess.Testing`):

Speech capture framework for automated testing. Per META-02: "Speech capture testing framework for automated regression testing."

```csharp
public static class SpeechCapture
{
    private static bool _capturing;
    private static readonly List<string> _captured = new List<string>();

    public static void Start()
    {
        _captured.Clear();
        _capturing = true;
        SpeechEngine.OnSpeechOutput += OnCapture;
    }

    public static List<string> Stop()
    {
        _capturing = false;
        SpeechEngine.OnSpeechOutput -= OnCapture;
        return new List<string>(_captured);
    }

    private static void OnCapture(string text)
    {
        if (_capturing) _captured.Add(text);
    }

    // Assertion helpers for tests
    public static bool ContainsText(string substring)
    {
        return _captured.Any(s => s.Contains(substring));
    }

    public static bool LastSpeechWas(string expected)
    {
        return _captured.Count > 0 && _captured[_captured.Count - 1] == expected;
    }

    public static int Count => _captured.Count;

    public static string LastSpeech => _captured.Count > 0 ? _captured[_captured.Count - 1] : null;
}
```

Hooks into `SpeechEngine.OnSpeechOutput` (the callback added in Plan 01 Task 2).

**Update Mod.cs:**
- Add InputInterceptor MonoBehaviour creation in OnLoad (after speech init)
- Register the two Phase 1 hotkeys (toggle + help)
- Add shutdown cleanup in a Game.OnDestroy patch (via InputPatches.cs)
  </action>
  <verify>
- InputInterceptor MonoBehaviour compiles and can detect F12 / Ctrl+Shift+F12 key presses
- HotkeyRegistry.TryHandle is called with correct AccessContext
- VanillaMode.Toggle fires on Ctrl+Shift+F12 and speaks confirmation
- F12 speaks help text listing available commands
- SpeechCapture.Start/Stop correctly captures speech output via OnSpeechOutput hook
- SpeechCapture assertion helpers (ContainsText, LastSpeechWas) work correctly
- Game.OnDestroy patch calls SpeechEngine.Shutdown
  </verify>
  <done>
InputInterceptor handles keyboard input via MonoBehaviour Update, routing to HotkeyRegistry. Toggle (Ctrl+Shift+F12) and Help (F12) hotkeys work. SpeechCapture hooks into SpeechEngine callback for test assertions. Game shutdown properly cleans up Tolk.
  </done>
</task>

</tasks>

<verification>
1. Ctrl+Shift+F12 toggles mod off: speaks "Oni-Access off", all subsequent speech calls are silenced
2. Ctrl+Shift+F12 toggles mod on: speaks "Oni-Access on", speech resumes
3. F12 speaks list of available commands for current context
4. When mod is off, only Ctrl+Shift+F12 works; F12 and all other mod hotkeys are inactive
5. SpeechCapture.Start() -> trigger speech -> SpeechCapture.Stop() -> assert captured text matches expected
6. Game shutdown calls SpeechEngine.Shutdown without errors
7. No hardcoded English in user-facing text -- all uses STRINGS.ONIACCESS
</verification>

<success_criteria>
- VanillaMode toggle works bidirectionally with correct speech output per locked decisions
- HotkeyRegistry supports context-sensitive binding registration with help text generation
- InputInterceptor routes keyboard events to HotkeyRegistry with frame dedup
- SpeechCapture provides Start/Stop/assertion API for test verification
- All Phase 1 hotkeys documented with original function per META-05 (both are unbound keys, documented as null)
- Harmony patch ensures clean Tolk shutdown on game exit
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
